# 05_input_05_command_injection_02_args（option_injection）

## 目的（このファイルで到達する状態）
- shell を使っていない（メタ文字が効かない）状況でも成立する **argvベースのコマンド注入**を、
  1) どの入力が argv のどの位置に入るか（値位置か、オプション位置か）  
  2) そのコマンドの引数パーサ（getopt / subcommand / @file / config）に何を許しているか  
  3) 低侵襲な差分観測で「オプションとして解釈された」を確定できるか  
  4) 修正案を “入力フィルタ” ではなく “argv設計” に落とせるか  
  まで説明・判断できる状態になる。

## 前提（対象・範囲・想定）
- 対象：Webアプリが外部コマンドを「引数配列」で実行している箇所、画像/PDF変換、アーカイブ、ネットワーク疎通、ログ整形、バックアップ、動画処理など
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - 本ファイルの範囲：**shell=False を前提**（メタ文字は効きにくい）、それでも「入力が `-` で始まる」「引数位置が曖昧」「end-of-options未使用」などで、入力が"オプション"として扱われ得る
  - 非スコープ（他ファイル）：メタ文字/パイプ等：`01_shell`、環境（PATH/LD_PRELOAD等）：`03_env`
- できること/やらないこと（安全に検証する範囲）：
  - できること：どの入力が argv のどの位置に入るか（値位置か、オプション位置か）、そのコマンドの引数パーサ（getopt / subcommand / @file / config）に何を許しているか、低侵襲な差分観測で「オプションとして解釈された」を確定できるか、修正案を "入力フィルタ" ではなく "argv設計" に落とせるか
  - やらないこと：影響実証は最小限（"値がオプションとして解釈された"根拠 + 影響の方向性まで）。高負荷/外部到達/大量出力は避ける
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/05_input_05_command_injection_01_shell（metachar_pipeline）.md`
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

## なぜ“攻撃より”に見るべきか：option injectionは「RCE」ではなく「モード切替」で壊す
- 典型的な誤解
  - 「shellじゃないから安全」→ **誤り**（安全になりやすいが、argvの設計が悪いと“別モード実行”が起きる）
- option injectionの本質
  - 入力が“値”から“命令（オプション）”へ昇格し、コマンドの挙動を変える
- 現実の影響（例：方向性）
  - 出力先/入力元/処理対象の切替（生成物の保存先、上書き、権限境界の破壊）
  - 余計な情報出力（ヘルプ、設定、詳細ログ）
  - 外部到達（URLを読みに行く/プロキシを使う）※コマンド次第
  - 高負荷（大量処理、再帰、巨大展開）※DoS寄り
  - “別コマンド”の実行そのものは、通常は shell より難しいが、**@file / config / subcommand** で実質的に命令面積が増えるケースがある

---

## 境界モデル（入力→argv→パーサ→実行モード）

### 1) argv境界：入力が入る「位置」がすべて
- argvは一般にこう解釈される
  - `cmd [options] <positional-args>`
- 事故は次で起きる
  - 入力が options として解釈される位置に入っている
  - あるいは、positionalだが parser が “先頭が-ならoption扱い” する（end-of-optionsがない）
- 特に危険な設計パターン
  - `cmd <USER_INPUT>` のように、入力が第一引数で、かつ `--` を入れていない
  - `cmd <fixed opts> <USER_INPUT> <more>` で、入力が “境界の間” に挟まっている（誤解釈しやすい）

### 2) parser差分：同じ “-” でもコマンドごとに意味が違う
- getopt系（典型）
  - `-x` `--long` を option として解釈
  - `--` 以降は option 解釈を止める（GNU/POSIX系に多い）
- subcommand系
  - `cmd <subcommand> ...` の subcommand が増えると、入力面が増える
- “@file / config” 系（危険に寄りやすい）
  - 引数として “ファイルから追加引数を読む” 形をサポートするツールがある（ここは特に設計レビュー対象）
- “デフォルト動作が危険”系
  - 入力をURL/パスとして解釈し、ネットワークやファイルに触れに行くタイプ

### 3) 影響面の分類（報告にそのまま使える）
- I（情報）：余計な出力（help/version/verbose/diag/config表示）
- W（書込み）：出力先や上書き挙動の変化（保存先、権限境界）
- N（ネットワーク）：到達性の発生（外部参照、プロキシ、リダイレクト）
- D（可用性）：高負荷化（再帰、巨大展開、無制限処理）
- A（認可）：本来触れない対象（別tenantのパス/領域）へ触れる導線（多くは“設計不備×実行権限”の複合）

---

## 成立根拠（差分＝oracle）の取り方：安全寄りで確定する

### 1) 最優先の低侵襲差分：help/versionで“オプション扱い”を確定
- 狙い：破壊的な動作を避けつつ、「値ではなくオプションとして解釈された」を確定する
- 成立サイン（例）
  - 入力を変えると、出力が “Usage/Help/Version” 寄りに変化する
  - エラーが “unknown option / invalid flag” のような parser エラーに寄る
  - 同じ値でも、先頭に `-` を付けるだけで挙動が変わる

### 2) `--`（end-of-options）で“止まるか”を見る（防御差分として強い）
- 実務上の価値
  - `--` を挿入できる実装なら、それだけで対策が成立するケースがある
- 観測
  - `--` を入れた場合に挙動差分が収束するなら、「end-of-options未使用」が根本原因として強く言える
- 注意
  - アプリ側が `--` を挿入していない場合、攻撃者が入力で `--` を混ぜられるかは実装次第（できる/できないの差が設計品質）

### 3) “生成物”差分（中侵襲）：出力ファイル名・ログ・ジョブ状態
- レスポンスに出ない系で有効
  - 非同期ジョブ、バックエンド処理、ストレージ保存
- 根拠として強い
  - 生成物のパスやメタデータが変わる
  - ジョブの状態遷移（成功/失敗/処理時間）が変わる
- 注意
  - 破壊的・大量出力になり得るため、影響が小さい条件（テスト領域、短い入力、低負荷）で限定する

### 4) 時間差（最後の手段）
- blind系での補助。だがDoSと紙一重になりやすい
- 「時間差が出る＝成立」ではなく、他の根拠（エラー/状態/生成物）と組み合わせる

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - どの入力が argv のどの位置に入るか（値位置か、オプション位置か）、そのコマンドの引数パーサ（getopt / subcommand / @file / config）に何を許しているか、低侵襲な差分観測で「オプションとして解釈された」を確定できるか、修正案を "入力フィルタ" ではなく "argv設計" に落とせるか
- 何が"推定"できるか（推定の根拠/前提）：
  - まず Boolean oracle（挙動差分、エラー差分、生成物差分）で確定する（推奨）
  - エラー差分は補助（parserエラーの形が変わる、usage/help っぽくなる）
  - 時間差分は最後（短時間・少回数で、他指標と組み合わせる）
- 何は"言えない"か（不足情報・観測限界）：
  - "任意コマンド実行が可能"の断定（環境/設定/権限で差が大きい）、"DoSが可能"の断定（性能試験は別枠、契約と安全配慮が必要）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：ファイル名/パスが第一引数に入る（最頻） → "パスは安全"という思い込み（しかし先頭 `-` のパス、相対、特殊文字がある）、"値としてのパス"を"オプション"に昇格させて、実行モードを変える
  - パターンB：ユーザが "検索条件式" を渡す（grep/awk/sed/ffmpeg等の引数世界） → 高機能ゆえに、引数が"ミニ言語"になる、式の自由度を使って情報・可用性へ影響
  - パターンC：サブコマンド型ツール（git等）をラップしている → "運用者向け"機能が一般ユーザ経由で叩けると、入力面が爆発する、subcommand/option の組合せで、想定外の対象へ到達（情報/書込み/ネットワーク）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - 画像/PDF変換、アーカイブ、ネットワーク疎通、ログ整形、バックアップ、動画処理など、外部コマンドを「引数配列」で実行している箇所
- 優先度の付け方（時間制約がある場合の順序）：
  - まず外部コマンド利用が疑わしい機能を"現実起点"で列挙する（変換/圧縮/ダウンロード/バックアップ/診断系（ping等）/ログ整形/レポート生成）、argvの位置を推定する（どこに入るか）、入力が「パス」か「検索語」か「オプション相当」かを分類する
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：end-of-options（`--`）を使っていない → 多くのCLIは `--` でオプション解釈を止められる、"ユーザ入力をpositionalとして渡す"場合は、必ず `--` を挿入する（コマンドが対応している前提）
  - 攻め筋2：入力が「オプション位置」に入っている（argvレイアウト不良） → `cmd <USER> <FIXED>` のように、固定引数より前にユーザ入力がある
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - Command Injection の一形態として扱うが、焦点は「メタ文字」ではなく **argv 境界**（`shell=False`でも成立する）、テストは payload ではなく「差分＝成立根拠」（挙動/エラー/出力/生成物）で確定する

## 典型シナリオ（現実寄り）：どういう機能で起きるか

### シナリオA：ファイル名/パスが第一引数に入る（最頻）
- 例：変換ツールに入力パスを渡す、圧縮対象を渡す、ログファイル名を渡す
- なぜ起きるか
  - “パスは安全”という思い込み（しかし先頭 `-` のパス、相対、特殊文字がある）
- 攻撃の狙い
  - “値としてのパス”を“オプション”に昇格させて、実行モードを変える

### シナリオB：ユーザが “検索条件式” を渡す（grep/awk/sed/ffmpeg等の引数世界）
- 例：フィルタ式、正規表現、フォーマット文字列
- なぜ起きるか
  - 高機能ゆえに、引数が“ミニ言語”になる
- 攻撃の狙い
  - 式の自由度を使って情報・可用性へ影響（ただし本ファイルは“option injection”が主なので、式言語は別観点として切り出す判断も重要）

### シナリオC：サブコマンド型ツール（git等）をラップしている
- 例：`tool <USER_ACTION> <ARGS...>` のような“便利ラッパ”
- なぜ起きるか
  - “運用者向け”機能が一般ユーザ経由で叩けると、入力面が爆発する
- 攻撃の狙い
  - subcommand/option の組合せで、想定外の対象へ到達（情報/書込み/ネットワーク）

---

## 深掘り：option injection を発生させる設計ミス（根本原因）

### 原因1：end-of-options（`--`）を使っていない
- 多くのCLIは `--` でオプション解釈を止められる
- 対策の王道
  - “ユーザ入力をpositionalとして渡す”場合は、必ず `--` を挿入する（コマンドが対応している前提）
- 追加の注意
  - `--` 非対応のツールもある。非対応なら allowlist/拒否（先頭 `-`）/専用APIへ置換が必要

### 原因2：入力が「オプション位置」に入っている（argvレイアウト不良）
- 例：`cmd <USER> <FIXED>` のように、固定引数より前にユーザ入力がある
- 対策
  - argvの順序を固定し、ユーザ入力は最後のpositionalへ
  - 可能なら “値専用のフラグ（例：--input <value>）” で渡す（ただし、そのフラグ自体は固定で、入力は value のみ）

### 原因3：語彙（フラグ/サブコマンド）を入力に委譲している
- 例：`mode` をそのまま subcommand にする、`format` をそのままオプション名にする
- 対策
  - UI選択肢→サーバ側マッピング（allowlist）で固定語彙へ変換する
  - “未知の語彙”は統一エラーで拒否（エラー詳細は出さない）

### 原因4：正規化・分割の不備（スペース分割/配列化の誤り）
- 典型事故
  - `user="a b"` を `split(" ")` して argv を増やしてしまう
- 対策
  - 入力は“1引数”として保持する（配列化はサーバ側が行い、ユーザ入力で増やさない）
  - どうしても複数値なら、配列として受け、型/上限/要素検証を行う

### 原因5：実行権限が強すぎる（影響を増幅）
- 同じoption injectionでも、実行ユーザが強いと影響が急増する
- 対策
  - 実行ユーザを最小化（権限分離、コンテナ、seccomp/AppArmor等）
  - 書込み先ディレクトリを固定（サンドボックス）

---

## 検証手順（攻撃寄りの思考で、しかし安全に）

### 手順1：外部コマンド利用が疑わしい機能を“現実起点”で列挙する
- 変換/圧縮/ダウンロード/バックアップ/診断系（ping等）/ログ整形/レポート生成
- “入力がコマンドへ渡る”候補を、UI項目・APIパラメータ・ファイル名に落とす

### 手順2：argvの位置を推定する（どこに入るか）
- 入力が「パス」か「検索語」か「オプション相当」かを分類する
- 推定が外れても良い。次の差分観測で当てに行く

### 手順3：低侵襲な“オプション扱い”確認を行う
- 目的：破壊せず、成立根拠を得る
- 観測
  - 挙動が usage/help っぽくなる
  - parserエラーの形が変わる
  - `--` を（可能なら）挿入した時に収束する

### 手順4：影響面を最小で実証する（I/W/N/D/Aのどれか）
- I（情報）で止められるなら、まずIで根拠化（最小）
- W/N/D は副作用が出やすいので、テスト領域・短い入力・回数制限で限定する
- “本番での負荷/外部到達”は原則避け、設計不備として提案に寄せる

---

## command_injection_args_key（正規化キー：次の一手に繋ぐ）
- 推奨キー：command_injection_args_key
  - command_injection_args_key =
    <shell_involved>(no)
    + <argv_position>(first|middle|last|unknown)
    + <parser_type>(getopt|subcommand|atfile|config|unknown)
    + <end_of_options_supported>(yes/no/unknown)
    + <observable>(help|error|file|job_state|timing|unknown)
    + <impact_axis>(I|W|N|D|A|unknown)
    + <exec_context>(privileged|same_user|container|unknown)

---

## 防御設計（修正案：入力フィルタから脱却）

### 1) argv設計の固定（最優先）
- ユーザ入力は positional の最後へ
- 可能なら “値専用フラグ” で渡す（フラグ名は固定、値は入力）
- 位置が揺れる実装（条件で引数が前後する）を避ける

### 2) `--`（end-of-options）の強制
- ツールが対応しているなら必ず入れる
- 対応していないなら
  - 先頭 `-` の拒否（allowlist）
  - そもそも外部ツールをやめてライブラリ置換（最も確実）
  のいずれかに寄せる

### 3) allowlist（語彙を入力に渡さない）
- サブコマンド/オプション/フォーマット指定を外部入力にしない
- UIの選択肢は内部マッピングで固定語彙へ変換する

### 4) 分割禁止（splitでargvを増やさない）
- 入力は単一引数として保持
- 複数値が必要なら配列として受け、型・長さ・要素検証を行う

### 5) 権限・書込み先の制限（影響の局限）
- 実行ユーザを最小権限へ
- 作業ディレクトリを固定（chroot/コンテナ/専用tmp）
- ネットワーク到達（egress）を制限（必要最小限）

### 6) 監査（攻撃の“探索行動”を拾う）
- argvのハッシュ化/正規化ログ（機微値はマスク）
- `--help`/`--version` 相当の探索パターン、異常な失敗率、短時間の繰り返しを検知

---

## 手を動かす検証（Labs連動：現実寄りに再現）
- 目的：shellなしでも argv で壊れること、`--` の有無で差分が収束することを体で理解する
- 最小構成（推奨）
  - (1) 悪い例：`cmd <USER_INPUT>`（`--`なし、first arg）
  - (2) 良い例：`cmd -- <USER_INPUT>`（end-of-options強制）
  - (3) 悪い例：`split(" ")` で argv が増える
  - (4) 良い例：入力は1引数、複数値は配列で受ける
- 観測点
  - HTTP差分（同一操作で入力だけ変更）
  - アプリログ：argv構造（長さ、位置、固定フラグの有無）、exit code、stderr分類
  - 生成物：保存先固定か、想定外の生成がないか

---

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 悪い例（概念）：ユーザ入力が第一引数、end-of-optionsがない
execve(["tool", USER_INPUT])

# 良い例（概念）：end-of-optionsを入れ、入力はpositionalとして固定
execve(["tool", "--", USER_INPUT])
~~~~

- この例で観測していること：end-of-options（`--`）の使用、argvの位置設計、入力がオプション位置に入っているか
- 出力のどこを見るか（注目点）：挙動差分、エラー差分、生成物差分、`--` を入れた場合に挙動差分が収束するか
- この例が使えないケース（前提が崩れるケース）：`--` 非対応のツールもある。非対応なら allowlist/拒否（先頭 `-`）/専用APIへ置換が必要

~~~~
# 悪い例（概念）：ユーザ入力を分割してargvが増える（語彙が混ざる）
args = ["tool"] + USER_INPUT.split(" ")
execve(args)

# 良い例（概念）：複数値は配列で受け、各要素を検証してからargvへ
args = ["tool", "--", item1, item2]  # itemNは検証済み
execve(args)
~~~~

- この例で観測していること：正規化・分割の不備、入力の配列化、argv構造の固定
- 出力のどこを見るか（注目点）：argv構造（長さ、位置、固定フラグの有無）、exit code、stderr分類
- この例が使えないケース（前提が崩れるケース）：入力がそもそも配列として扱われていない場合、または完全に静的な引数のみを使用している場合

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V5 Validation, Sanitization and Encoding、V7 Error Handling and Logging
  - 該当要件（可能ならID）：V5.3.1、V5.3.2、V7.4.1
  - このファイルの内容が「満たす/破れる」ポイント：
    - 入力→実行境界：shell を呼ばなくても、外部コマンドの **引数解釈（getopt 等）** が"第二の言語"になる。入力が「値」ではなく「オプション」として解釈されない設計が必要
    - 重要：フィルタ（危険文字除去）ではなく、(1) 引数配列の固定、(2) allowlist、(3) `--`（end-of-options）の強制、(4) 位置引数の固定（入力をオプション位置へ置かない）
    - 監査：プロセス生成、argv、呼出元（trace_id）を相関し、オプション注入の探索行為（--help/--version等の揺さぶり）を検知できるか
- WSTG：
  - 該当カテゴリ/テスト観点：WSTG-INPV-12 Command Injection
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：
    - Command Injection の一形態として扱うが、焦点は「メタ文字」ではなく **argv 境界**（`shell=False`でも成立する）
    - テストは payload ではなく「差分＝成立根拠」（挙動/エラー/出力/生成物）で確定する
- PTES：
  - 該当フェーズ：Vulnerability Analysis、Exploitation、Reporting
  - 前後フェーズとの繋がり（1行）：外部コマンドの候補（画像/PDF/ネットワーク/アーカイブ/ログ整形）→ 実行関数（spawn/execve）→ argv構造を仮説化し、影響実証は最小限（"値がオプションとして解釈された"根拠 + 影響の方向性まで）。高負荷/外部到達/大量出力は避ける、原因を「argvの位置設計ミス」「end-of-options未使用」「allowlist不在」「入力正規化不備」「実行権限過大」に分解して提案
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：Execution
  - 攻撃者の目的（この技術が支える意図）：外部コマンドを"意図しないモード"で動かす、典型の後続：収集（Collection）、持ち出し（Exfiltration）、権限悪用（Privilege Escalation）は環境依存。まずは"制御点がargvにある"ことを確定する

## 参考（必要最小限）
- OWASP WSTG：Testing for Command Injection（WSTG-INPV-12）
- CWE-78：OS Command Injection
- MITRE ATT&CK：T1059 Command and Scripting Interpreter

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/05_input_05_command_injection_01_shell（metachar_pipeline）.md`
- `01_topics/02_web/05_input_11_path_traversal_01_normalization（dotdot_encoding）.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 深掘りリンク（最大8）
- `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
- `01_topics/02_web/05_input_05_command_injection_01_shell（metachar_pipeline）.md`
- `01_topics/02_web/05_input_05_command_injection_03_env（path_ld_preload）.md`
- `01_topics/02_web/05_input_11_path_traversal_01_normalization（dotdot_encoding）.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
