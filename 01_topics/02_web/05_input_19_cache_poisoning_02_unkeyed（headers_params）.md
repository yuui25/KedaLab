# 05_input_19_cache_poisoning_02_unkeyed（headers_params）

## このファイルで扱う概念
- Unkeyed入力（ヘッダ/パラメータ）による汚染境界。

## 危険性を一言で
- キーに入らない値で応答が変わる。

## 最小限の成立判断（目安）
- Unkeyed差分で応答が変わる。

## 観測例（差分のイメージ）
- A: 通常、B: 変化した応答が保存される。

## 観測が取れない場合の代替
- Varyとキャッシュキーの構成を確認する。

## 時間制約下の最小観測点
- ヘッダ/パラメータの影響有無。

## 対策の優先順位
1) Unkeyedの影響排除
2) Varyの明示
3) 返却の固定化

## 具体例（候補）
- ヘッダ: `X-Forwarded-Host`, `X-Original-URL`, `Accept-Encoding`
- パラメータ: `utm_*`, `debug`, `cachebust`
Cache Poisoning（Unkeyed）：キーに入らない入力（ヘッダ/パラメータ）がレスポンスを変えると、攻撃者は"他者に配るレスポンス"を作れる

---

## 目的（この技術で到達する状態）
- 「キー（Keying）は分かった」次に、**キーに入っていないのにレスポンスへ影響する入力（unkeyed）** を安全に特定できる。
  1) unkeyed候補の"体系"を持ち、闇雲に試さない
  2) 影響の種類（表示差/リンク差/リダイレクト差/エラー差/キャッシュ制御差）を分類できる
  3) 成立根拠（unkeyedでレスポンス差 + キャッシュ格納/再利用）を証跡で取れる
  4) 第三者影響を最小化しながら、侵害評価（誰に影響するか）へ繋げられる
  5) 修正要求を「キーへ含める/キャッシュ不可/正規化/入力無視」の設計要件で提示できる

## 前提（対象・範囲・想定）
- 対象：許可された範囲のWebアプリ/環境のみ。
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - 多段キャッシュ（ブラウザ/CDN/Reverse Proxy/アプリ内）が一般的。中継点（CDN/Proxy）のキーとオリジン処理がズレることで成立する。
- できること/やらないこと（安全に検証する範囲）：
  - やる：unkeyed候補の安全な絞り込み、影響半径の最小化（隔離/短TTL/低頻度）、証跡ベースで所見化
  - やらない：第三者影響が出やすいため、原則は Lab / ステージング / 許可された隔離環境で実施。実運用で"配布"が疑われる検証は、必ず合意と範囲の明確化を先に行う。
- 依存する前提知識（必要最小限）：
  - `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：unkeyed input（headers_params）でのキャッシュ汚染"入口"
    - ヘッダ：代理ヘッダ、内部ルーティング、表現（言語/圧縮/UA）、CORS/Origin周り など
    - パラメータ：無視される/正規化されるクエリ、フレームワークの特殊パラメータ など
    - 観測：Hit/Miss、レスポンス差分、ログ相関、層の切り分け
  - 扱わない（別ユニットへ接続）：
    - poisoned object（stored response配布の評価） → `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
    - keyingの確定 → `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - キャッシュが効いている層（Hit/Missの"証拠"）：レスポンスヘッダ（Cache-Control/Vary/Age等）、1回目/2回目の時間差、可能ならキャッシュ層ログ（hit/miss、bypass理由）
  - レスポンス差分（1軸だけ）：HTML内の絶対URL（scheme/host）、Location（リダイレクト先）、参照する静的ファイル（script/link）、JSONのURLやフラグ
  - キーに入っていない証拠：同じURLで、入力を変えても **同一のキャッシュが返る** 兆候（Hit/Missが同じ、Ageが進む、ログ上で同一キー扱い）
  - 層間差（CDN/Proxy/Originのどこが原因か）：cacheログ（キー構成要素）、originログ（受信したHost/path/query/代理ヘッダ）
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：どの層（CDN/Proxy/Origin）がキーを決定し、どこで入力が解釈されるか
  - 信頼境界（外部連携・第三者・越境ポイント）：中継点（CDN/Proxy）のキーとオリジン処理がズレることで成立する
  - 権限境界（権限の切替/伝播/委任）：ユーザ境界（ログイン/個人化）、テナント境界（subdomain/org_id）、機能境界（/admin/設定/エクスポート）、表現境界（言語/圧縮/デバイス）、経路境界（http/https、ホスト、内部ルーティング、パス正規化）
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - unkeyed input の定義：**レスポンスに影響するが、キャッシュキーに含まれていない入力**
  - 必要条件（3点セット）：1) キャッシュされる（または再利用される）レスポンスである、2) そのレスポンスが、ある入力で変化する、3) その入力がキーに入っていない（＝別入力でも同じキャッシュが返る）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - unkeyed成立の3条件が揃っている：キャッシュが効いている、レスポンスが入力で変化する、その入力がキーに入っていない
  - 層間不一致（設計欠陥）：Originはヘッダを受け取っているが、キャッシュ層はキーへ入れていない
- 何が"推定"できるか（推定の根拠/前提）：
  - 影響半径（誰に配布され得るか：ユーザ/テナント/匿名）を評価し、`03_poisoned_object` へ接続
  - 実害評価（レベル1：表現差止まり、レベル2：リンク/遷移/参照資源が変わる、レベル3：境界に触れる）
- 何は"言えない"か（不足情報・観測限界）：
  - すべてのunkeyed候補を網羅した断定（観測範囲に依存）
  - すべての層での完全な断定（観測範囲に依存）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：キャッシュが効いていない → unkeyed探索に進まない（全部が揺れる）
  - パターンB：レスポンスが変わるが、キーに入っている → unkeyedではない（健全）
  - パターンC：レスポンスが変わり、キーに入っていない → unkeyed成立（危険）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - 代理/経路ヘッダ（Reverse Proxy配下で最優先）：Forwarded / X-Forwarded-Host 系、Forwarded / X-Forwarded-Proto 系、X-Original-URL / X-Rewrite-URL / X-Forwarded-Uri 系
  - 内部機能フラグ系：A/Bテスト、段階ロールアウト、実験フラグ、デバイス/アプリ種別、Geo/言語
  - CORS/Origin系（APIで事故りやすい）
- 優先度の付け方（時間制約がある場合の順序）：
  1) 代理/経路ヘッダ（Reverse Proxy配下で最優先） → 絶対URL（リンク、OGP、Location、フォームaction）の生成差、http↔httpsの切替差
  2) 内部機能フラグ系 → HTMLの差分（リンク先、スクリプト読み込み、フォーム先）、JSONのフィールド差分（フラグ値、URL、リソース）
  3) CORS/Origin系 → 本来別Origin向けのCORSレスポンスが混線（誤許可/誤拒否）し得る
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：ヘッダでHTMLの絶対URL/Locationが変わる → そのヘッダがキーに入っているか（Vary/ログ/Hit継続）を確定
  - 攻め筋2：言語/UAでHTML断片やJS参照が変わるが、Varyがない → CDNが暗黙にキーへ入れていないか（ログ/ベンダ仕様）を確認し、衝突の証拠を取る
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - キャッシュ層ログが取れない場合：レスポンスヘッダ（Cache-Control/Vary/Age等）、1回目/2回目の時間差で推定
  - 層間差を切り分けられない場合：cacheログとoriginログの相関が取れないため、断定を避け、**観測された状態**として位置づける

## 次に試すこと（仮説A/Bの分岐と検証）
- 仮説A：キャッシュが効いている層を確定（Hit/Missの"証拠"を取る）
  - 成立条件：
    - レスポンスヘッダ（Cache-Control/Vary/Age等）、1回目/2回目の時間差、可能ならキャッシュ層ログ（hit/miss、bypass理由）が取れる
  - 次の検証：
    - ここで曖昧なら、unkeyed探索に進まない（全部が揺れる）
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功：キャッシュが効いている層が確定する
    - 失敗：キャッシュが効いていない、または層が不明確（unkeyed探索に進まない）
- 仮説B：レスポンスが変わるが、キーに入っている（unkeyedではない）
  - 成立条件：
    - 同じURL・同じ条件で、対象の入力だけ変えるとレスポンスが変わる
    - しかし、その入力がキーに入っている（Vary/ログ/Hit継続で確認）
  - 次の検証：
    - 他のunkeyed候補を探索する
  - 期待する観測：
    - 成功：レスポンスが変わるが、キーに入っている（健全）
    - 失敗：レスポンスが変わり、キーに入っていない（unkeyed成立）
- 仮説C：レスポンスが変わり、キーに入っていない（unkeyed成立）
  - 成立条件：
    - 同じURLで、入力を変えても **同一のキャッシュが返る** 兆候（Hit/Missが同じ、Ageが進む、ログ上で同一キー扱い）
  - 次の検証：
    - 影響半径（誰に配布され得るか：ユーザ/テナント/匿名）を評価し、`03_poisoned_object` へ接続
  - 期待する観測：
    - 成功：unkeyed成立が確定し、影響半径が評価できる
    - 失敗：影響半径が評価できない（ただしunkeyed成立は確定）

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/02_web/05_input/19_cache_poisoning_02_unkeyed_headers_params/`（追加候補）
- 取得する証跡（目的ベースで最小限）：
  - レスポンスヘッダ（Cache-Control/Vary/Age等）、1回目/2回目の時間差、可能ならキャッシュ層ログ（hit/miss、bypass理由）
  - レスポンス差分（HTML内の絶対URL、Location、参照する静的ファイル、JSONのURLやフラグ）
  - キーに入っていない証拠（Hit/Missが同じ、Ageが進む、ログ上で同一キー扱い）
  - 層間差（cacheログ：キー構成要素、originログ：受信したHost/path/query/代理ヘッダ）
- 観測の取り方（どの視点で差分を見るか）：
  - 視点1：キャッシュが効いている層の確定
  - 視点2：レスポンス差分の確定（1軸だけ）
  - 視点3：キーに入っていない証拠の確定
  - 視点4：層間差の切り分け
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/cache_poisoning_unkeyed 2>/dev/null
    cd ~/keda_evidence/cache_poisoning_unkeyed
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **少数回で証跡重視**（第三者影響の抑制）
      - 実運用で"配布"が疑われる検証は、必ず合意と範囲の明確化を先に行う
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host、User、Time、キャッシュ層、キー構成要素、レスポンス差分、層間差

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# Unkeyedは第三者影響が出やすい。

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：キャッシュ設定、データ保護
  - 該当要件（可能ならID）：レスポンスに影響する入力（Host/Proto/Path/Client属性/言語/圧縮/内部ルーティング等）を体系的に棚卸しし、(1) キーへ含める、(2) キャッシュ不可にする、(3) 正規化して差分を潰す、のいずれかへ落とす。特に"代理ヘッダ（X-Forwarded-* 等）""内部ルーティング用ヘッダ（X-Original-URL 等）"は危険側に倒して扱う。
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：キャッシュキーに入らない入力（unkeyed input）がレスポンス生成に影響すると、攻撃者が"特定条件のレスポンス"をキャッシュへ格納し、他者へ配布できる。これは認証・認可が正しくても「キャッシュが境界を破る」形で情報露えい・誤配布・混線を生む。
    - 満たす：レスポンスに影響する入力（Host/Proto/Path/Client属性/言語/圧縮/内部ルーティング等）を体系的に棚卸しし、(1) キーへ含める、(2) キャッシュ不可にする、(3) 正規化して差分を潰す、のいずれかへ落とす。特に"代理ヘッダ（X-Forwarded-* 等）""内部ルーティング用ヘッダ（X-Original-URL 等）"は危険側に倒して扱う。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：キャッシュ関連の誤動作
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：Cache Poisoningは「入力→出力」だが、中継点（CDN/Proxy）のキーとオリジン処理がズレることで成立する。本ファイルは "unkeyed（キーに入らないのに効く入力）" を、観測（Hit/Miss、ヘッダ、ログ相関）で特定し、成立根拠を作る。
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：脆弱性分析、侵害評価
  - 前後フェーズとの繋がり（1行）：脆弱性分析〜侵害評価。実環境では第三者影響が出やすいので、(1) Keying確定、(2) Unkeyed候補の安全な絞り込み、(3) 影響半径の最小化（隔離/短TTL/低頻度）を前提に、証跡ベースで所見化する。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：T1190（公開アプリ脆弱性悪用）
  - 攻撃者の目的（この技術が支える意図）：T1190（公開アプリ脆弱性悪用）に接続し得るが、本ファイルの焦点は "成立根拠の作り方"。Impact：不正コンテンツ配布、ユーザ混線、サービス劣化に接続し得る（条件付き）。Defense Evasion：キャッシュが原因だと、監査・再現性が落ち、検知・追跡が難化する。
  - 参照：https://attack.mitre.org/tactics/TA0001/（Initial Access）

## 参考（必要最小限）
- Cache Poisoning（Unkeyed）の定義と解説
- unkeyed候補の体系（ヘッダ編、パラメータ編）
- 観測で確定する手順（薄い所見にしないための必須手順）

## リポジトリ内リンク（最大3つまで）
- 関連 topics：`05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- 関連 topics：`05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- 関連 labs：`04_labs/02_web/05_input/19_cache_poisoning_02_unkeyed_headers_params/`（追加候補）

---

## 深掘りリンク（最大8）
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
- `06_config_01_CORSと信頼境界（Origin_資格情報_プリフライト）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`

---
