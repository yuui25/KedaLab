# 02_authn_02_session_lifecycle（更新_失効_固定化_ローテーション）
セッションの挙動（発行・更新・失効）を、**通信差分で yes/no/unknown** まで落として説明する

---

## 目的（この技術で到達する状態）
- セッションの挙動（発行・更新・失効）を、**通信差分で yes/no/unknown** まで落として説明できる。
- 「ログアウトしたのに使える」「一定時間で切れない」「認証直後に同じIDが続く」などの事象を、推測で断言せず **境界（どこで切れていないか）**として切り分けできる。
- 認証（Authn）と認可（Authz）を混ぜずに、まず“身元状態の寿命”を確定し、次の検証（IDOR等）へ接続できる。

## 前提（対象・範囲・想定）
- 対象：Cookieベース/トークンベース双方のセッション（Web/SPA/API）。
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - Web/SPA/API、SSO/MFA、CDN/WAFが一般的。
- できること/やらないこと（安全に検証する範囲）：
  - 観測は最小限の差分セットのみ（破壊的試験や過剰負荷は行わない）。
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/02_authn_00_認証・セッション・トークン.md`
  - `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：
    - セッションの発行・更新・失効・再利用可否の観測と差分検証
    - セッション固定化、ローテーション、Idle/Absolute Timeout、ログアウト失効、並行セッションの挙動
  - 扱わない（別ユニットへ接続）：
    - Cookie属性の詳細 → `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
    - トークン設計の詳細 → `01_topics/02_web/02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`

## 観測ポイント（何を見ているか：データ/状態/境界）
### まず確定する「状態遷移」
- 未認証 → 認証（ログイン）  
- 認証 → 維持（通常操作）  
- 認証 → 更新（延命/ローテーション）  
- 認証 → 失効（ログアウト/期限切れ/パスワード変更等）  
- 失効 → 再利用可否（古いセッションが通る/通らない）

### 収集する最小証跡（リクエスト/レスポンス）
- ログイン直後：
  - Set-Cookie（セッション識別子の発行）
  - 302/200 などの遷移（どの時点で発行されたか）
- 通常操作（数回）：
  - Cookie/Authorization の継続性（同じか変わるか）
  - レスポンスの差（200/401/403/302）
- ログアウト直後：
  - Set-Cookieでの削除（Expires過去、Max-Age=0等）有無
  - サーバ側の失効が反映されるか（同じセッションで再アクセス）
- 時間経過（Idle/Absolute）：
  - “何分で切れるか”ではなく、「いつ切れたか」「何が変わったか」を証跡で押さえる

## ライフサイクルの論点（意味→判断→次の一手）
### 1) セッション固定化（Session Fixation）
- 意味：ログイン前後で“同じセッション識別子が継続”し、攻撃者が事前に固定できる余地がある状態。
- 観測（差分）：
  - ログイン前に発行された識別子（Cookie/トークン）が、ログイン後も同一のままか
- 判断：
  - 同一のまま＝固定化リスクを疑う（ただし、実装が別のサーバ側対策を持つ可能性はあるため、ログ/挙動で補強）
- 次の一手：
  - “ログイン後に識別子がローテーションするか”を追加観測（固定化の否定要件）

### 2) ローテーション（セッションID更新）
- 意味：一定条件（ログイン、権限昇格、一定操作）で識別子を更新して再利用を困難にする。
- 観測（差分）：
  - ログイン直後/権限変更直後で、識別子が変わるか
- 判断：
  - 変わる＝奪取された識別子の寿命が短くなる方向
  - 変わらない＝奪取後の再利用余地が残る方向（ただし、サーバ失効等と合わせて評価）
- 次の一手：
  - “古い識別子が通るか”を必ず試す（更新しただけで古いのが通るなら意味が薄い）

### 3) Idle Timeout（無操作失効）
- 意味：一定時間操作がないと失効する（端末放置の影響を減らす）。
- 観測（差分）：
  - 無操作時間を置いた後の最初のリクエストで、401/302/再認証要求になるか
- 判断：
  - 失効する＝放置リスクを減らす方向
  - 失効しない＝放置・共有端末で影響が増える方向
- 次の一手：
  - “失効しない”場合、Absolute Timeout や logout 失効で補完されているかを確認

### 4) Absolute Timeout（最長寿命）
- 意味：操作があっても一定時間で失効する（長期乗っ取りの窓を減らす）。
- 観測（差分）：
  - 時間経過で必ず切れるか（切れる場合、どう切れるか：再認証/トークン更新要求）
- 判断：
  - 無い/極端に長い＝奪取後の再利用窓が広い方向
- 次の一手：
  - “更新（Refresh）”の有無と合わせて評価（更新で無限延命していないか）

### 5) ログアウト失効（Server-side Invalidation）
- 意味：ログアウトで“サーバ側”のセッションを無効化し、再利用を防ぐ。
- 観測（差分）：
  - ログアウト後、同一Cookie/トークンでAPIを叩くと拒否されるか
  - Cookie削除だけでなく、サーバ側の失効が効いているか
- 判断：
  - Cookie削除だけで、トークン/セッションがサーバで生きていると再利用余地が残る
- 次の一手：
  - 別端末/別タブ/別セッションでの挙動差（SSO/複数ログイン許可）も含め、境界（どの単位で失効するか）を確定

### 6) 並行セッション（複数端末ログイン）
- 意味：同一アカウントで複数セッションを許す/許さない（運用要件で変わる）。
- 観測（差分）：
  - 端末Aと端末Bで同時ログインしたとき、片方が無効化されるか
- 判断：
  - 許す＝利便性は高いが、奪取時の影響面が広がる可能性
  - 許さない＝奪取検知/締め出しがしやすいが、UX影響あり
- 次の一手：
  - 仕様の期待値（要件）と整合しているかをケースに明記（技術だけで断定しない）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - ログイン前後で識別子が変わる/変わらない（固定化の疑い）
  - ログアウト後に同一識別子が通る/通らない（失効の有無）
  - 無操作・時間経過で切れる/切れない（寿命設計）
- 何が"推定"できるか（推定の根拠/前提）：
  - セッション管理の設計意図（固定化対策、失効設計、寿命設計）
- 何は"言えない"か（不足情報・観測限界）：
  - サーバ側での失効理由（ブラックリスト/セッションストア/トークン検証）の詳細
  - 中間層での再認証誘導（SSO/ゲートウェイ）の影響（入口ログ/SSOログが必要）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：ログアウトが効いていない気がする → ログアウト直後に、同一Cookie/トークンで "状態参照API" と "状態変更API" を1回ずつ叩き、差分（200/401/403/302）を保存する
  - パターンB：ログイン前後で同じ識別子に見える → ログイン前のCookie（セッション候補）を保持し、ログイン後のSet-Cookieと比較して "同一か" を確定する
  - パターンC：一定時間で切れない／切れ方が不明 → 無操作→1回アクセス、操作継続→一定時間後アクセス、の2パターンを取り、Idle/Absoluteを分離して観測する

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- 優先度（最初に確定）
  1) ログアウト後の再利用可否（再利用できるなら影響が直結しやすい）
  2) ログイン前後の識別子変化（固定化の可能性）
  3) Idle/Absoluteの有無（奪取後の窓）
  4) ローテーションと古い識別子の扱い（更新の実効性）
- 次の仮説
  - “ログアウト後も通る”なら：Cookie削除のみの境界、またはトークン失効未実装を疑い、サーバ側根拠を取りに行く
  - “ログイン前後で同じ”なら：固定化余地を疑い、前提条件（攻撃者が固定できる経路があるか）を別途確認する
  - “時間で切れない”なら：運用要件を確認し、必要なら対策提案（Idle/Absolute）を具体化する

## 次に試すこと（仮説A/Bの分岐と検証）
### 仮説A：ログアウトが効いていない気がする
- 次に試すこと
  - ログアウト直後に、同一Cookie/トークンで “状態参照API” と “状態変更API” を1回ずつ叩き、差分（200/401/403/302）を保存する
- 期待する観測
  - 参照も変更も拒否される＝失効が効いている
  - 参照は通る/変更は拒否＝境界が別（Authz/CSRF）なので切り分ける
  - 両方通る＝失効未成立の可能性が上がる（追加根拠へ）

### 仮説B：ログイン前後で同じ識別子に見える
- 次に試すこと
  - ログイン前のCookie（セッション候補）を保持し、ログイン後のSet-Cookieと比較して “同一か” を確定する
- 期待する観測
  - ログイン後に新規発行＝固定化は否定方向
  - 継続＝固定化余地の可能性（ただし前提条件を詰める）

### 仮説C：一定時間で切れない／切れ方が不明
- 次に試すこと
  - 無操作→1回アクセス、操作継続→一定時間後アクセス、の2パターンを取り、Idle/Absoluteを分離して観測する
- 期待する観測
  - どちらで切れるか（または切れないか）を yes/no/unknown で言える

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
    - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
- 取得する証跡（目的ベースで最小限）：
  - Proxyログ：Set-Cookie / Cookie / Authorization ヘッダ差分
  - 必要時：HAR（ブラウザ）、サーバログ（ログイン/ログアウト/失効イベント）
  - 差分セット（最小）：ログイン前、ログイン直後、通常操作、ログアウト、ログアウト後
- 観測の取り方（どの視点で差分を見るか）：
  - 識別子の変化（ログイン前後、更新、ローテーション）、失効の有無（ログアウト後、時間経過）、再利用可否（古い識別子で再アクセス）
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/session_lifecycle 2>/dev/null
    cd ~/keda_evidence/session_lifecycle
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **最小限の差分セット** のみ
      - Cookie/トークンは秘匿情報。共有・提出・保管はルールに従う。
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host、User、Time、Cookie/Token、識別子の変化（ログイン前/後、更新、ローテーション）、失効状態（有効/失効/不明）、再利用可否（yes/no/unknown）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 例：ログイン前後の識別子変化を観測
curl -i https://example.com/login -d "username=test&password=test" -c cookies.txt
curl -i https://example.com/api/me -b cookies.txt

# 例：ログアウト後の再利用可否を観測
curl -i https://example.com/logout -b cookies.txt
curl -i https://example.com/api/me -b cookies.txt
~~~~

- この例で観測していること：
  - ログイン前後で識別子が変わる/変わらない（固定化の疑い）、ログアウト後に同一識別子が通る/通らない（失効の有無）
- 出力のどこを見るか（注目点）：
  - Set-Cookieヘッダ（識別子の発行/更新）、Cookieヘッダ（送信有無）、ステータスコード（200/401/403/302）
- この例が使えないケース（前提が崩れるケース）：
  - JS必須/SSO必須の場合、curlだけでは成立しない（ブラウザ+HAR/Proxyで観測へ）

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V3（Session Management）を中核に、V2（Authentication）/ V4（Access Control）/ V7（Logging）へ接続。更新・失効・固定化対策は"セッション境界の設計"そのもの。
  - 該当要件（可能ならID）：V3（Session Management）、V2（Authentication）
  - このファイルの内容が「満たす/破れる」ポイント：
    - 満たす：セッションのライフサイクルを観測で確定し、以後の検証観点を外さないための基盤。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：WSTG-SESS（Session Management）で、セッションの発行・更新・失効・再利用可否を「観測→差分」で確認するための実務メモ。
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：セッションライフサイクルの観測と理解
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：Vulnerability Analysis（成立条件の切り分け）→ Exploitation（再現）→ Reporting（根拠提示）。ライフサイクルは推測が入りやすいため、証跡で固める。
  - 前後フェーズとの繋がり（1行）：成立条件の切り分け→再現→根拠提示の品質を上げる。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：Valid Accounts / Session Hijacking
  - 攻撃者の目的（この技術が支える意図）：セッション再利用が可能だと、攻撃者は"認証突破"ではなく"状態再利用"を優先する判断になり得る。
  - 参照：https://attack.mitre.org/tactics/TA0001/（Initial Access - Valid Accounts）、https://attack.mitre.org/techniques/T1563/（Session Hijacking）

## 参考（必要最小限）
- OWASP Application Security Verification Standard: https://github.com/OWASP/ASVS
- OWASP Web Security Testing Guide: https://owasp.org/www-project-web-security-testing-guide/
- PTES (Penetration Testing Execution Standard): https://pentest-standard.readthedocs.io/
- MITRE ATT&CK: https://attack.mitre.org/

## リポジトリ内リンク（最大3つまで）
- 関連 topics：`01_topics/02_web/02_authn_00_認証・セッション・トークン.md`
- 関連 topics：`01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
- 関連 labs：`04_labs/01_local/02_proxy_計測・改変ポイント設計.md`

---

## 深掘りリンク（最大8）
- `01_topics/02_web/02_authn_00_認証・セッション・トークン.md`
- `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
- `01_topics/02_web/02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`
- `01_topics/02_web/02_authn_15_session_concurrency（多端末_同時ログイン制御）.md`
- `01_topics/02_web/02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

---
