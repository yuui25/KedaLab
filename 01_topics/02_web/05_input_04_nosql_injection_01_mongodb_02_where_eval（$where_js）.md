# 05_input_04_nosql_injection_01_mongodb_02_where_eval（$where_js）

## 目的（この技術で到達する状態）
- MongoDB の `$where`（JS評価）を、NoSQLi の中でも別格の「入力→コード評価」境界として切り出し、
  1) 入口（入力形式）と到達条件（どのAPI/どのマージ処理で$whereが混入するか）を特定できる  
  2) 成立根拠（oracle：件数/長さ/遅延/エラー）を安全に取れる  
  3) 影響（認可境界の崩壊、過負荷、監査回避）を“推測”でなく設計として説明できる  
  4) 修正を「サニタイズ」ではなく **$where禁止（機能の排除）** と **安全な代替（式/演算子の限定）** に落とせる  
  状態になる。

## 前提（対象・範囲・想定）
- 対象：MongoDB を使うWeb/APIで、`filter` / `where` / `query` のような「汎用条件」を受け取る設計、管理画面・検索API・ログ閲覧・可視化ダッシュボード等（柔軟検索が欲しくなる領域）
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - 成立しやすい構造：ユーザ入力JSONをそのまま find 条件へ渡す、既定条件（tenant/owner 等）とユーザ条件を "同階層マージ" している、"Mongoクエリをそのまま受ける" 仕様（内部ツールに多い）
  - 本ファイルの焦点：`$where` / JS評価の成立根拠と防御設計
  - 非スコープ（別ファイル）：集約パイプライン（pipeline）、BSON型混乱など
- できること/やらないこと（安全に検証する範囲）：
  - できること：$where を含むクエリ構造が入力から形成できる（入力→評価境界の破壊）、入口（どのパラメータ/どのモード/どのContent-Type）が原因か、oracle（件数/長さ/遅延/エラー）のうち、何が再現性のある根拠か、認可境界と同居している設計上の危険性（越境混入の可能性）を説明できる
  - やらないこと：具体的な実行結果の断定（内部実装や権限に依存）、高負荷・DoS成立の断定（性能試験は契約・安全性が必要）、DBが必ずMongoである断定（互換や抽象化がある）
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/05_input_04_nosql_injection_01_mongodb_01_operator（$ne_$gt_$regex）.md`
  - `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

## $where を「特別扱い」する理由（差分＝成立根拠）
- `$ne/$gt/$regex` は “クエリ演算子の注入” だが、`$where` は **JSコード評価** の側面がある
- したがって優先順位が変わる
  - まず “使わせない（禁止/無効化）” が原則
  - 次に “もし残るなら監査・制約・隔離” が必須
- 実務的な危険性（推奨の説明軸）
  - 認可境界（tenant/owner）と同じ場所で条件が評価される → 越境混入に繋がりやすい
  - 評価が重い → DoS/遅延が起きやすい（PTでは特に安全配慮）
  - エラーが出ると oracle になりやすい

## 観測ポイント（入力→クエリ構造→評価→反応）

### 1) 入口を確定する：$where を“どこから混入できるか”
- 典型入口（優先して疑う）
  - `filter` パラメータ（JSON文字列）をパースしてMongo条件にする
  - `where` パラメータ（文字列/JSON）をそのままクエリへ渡す
  - 画面側で“詳細検索”として条件式を受ける
- 入口確定の観測
  - Content-Type（json/form/query）によって混入可否が変わる
  - “同じ入力点”でも、特定のモード（advanced=true 等）でだけ混入する（実装分岐の兆候）
- 判断（次の一手）
  - 入口（どのパラメータがクエリ構造に変換されているか）を最優先で確定し、以後の検証はそこに固定する

### 2) 差分（oracle）指標を固定する（安全に確定する）
- Boolean oracle（推奨）
  - 結果件数、レスポンス長、表示要素数、ページネーション、特定レコードの有無
- Time oracle（補助、短時間・少回数）
  - $where は評価コストが差分になり得るが、DoSに近づく  
    → 実務では「短い遅延」「少回数」「他指標との併用」を原則にする
- Error oracle（補助）
  - 構文/参照エラーが返る場合は “DB評価到達” の補助証拠になるが、レポート上は **情報漏えい（例外モデル）** としても扱う

### 3) $where が混入する“境界破壊の型”を3分類で整理する（原因特定に直結）

#### 型A：ユーザ入力が `$where` キーを直接作れる（構造注入）
- 例：ユーザが `{ "$where": "..." }` を作れる経路がある
- 根本原因
  - クエリ構造を入力にさせている（allowlist不在、スキーマ検証不在）
- 修正の方向
  - `$` で始まるキーを禁止（ただしブラックリストに依存しすぎない）
  - 受理するフィールド/演算子をallowlist化し、アプリ独自DSLから生成する

#### 型B：既定条件とユーザ条件のマージが危険（同階層 merge / deep merge）
- 例：`base = { tenant_id: X }` と `userFilter` を同階層で混ぜる
- 根本原因
  - “権限条件” と “検索条件” が同じ構造で扱われ、上書き/混入が起きる
- 修正の方向
  - 既定条件は固定し、ユーザ条件は “安全に生成したサブ条件” としてAND結合する（入力オブジェクトを直接混ぜない）

#### 型C：文字列の “評価機構” に流れている（whereStringを評価）
- 例：詳細検索で `where="..."` のような条件式を受ける
- 根本原因
  - 機能要件が “評価” を必要としている（設計起因）
- 修正の方向
  - 文字列式ではなく、安全なDSL（eq/gt/contains 等）に落とし、サーバでクエリ生成する

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - $where を含むクエリ構造が入力から形成できる（入力→評価境界の破壊）
  - 入口（どのパラメータ/どのモード/どのContent-Type）が原因か
  - oracle（件数/長さ/遅延/エラー）のうち、何が再現性のある根拠か
  - 認可境界と同居している設計上の危険性（越境混入の可能性）を説明できる
- 何が"推定"できるか（推定の根拠/前提）：
  - まず Boolean oracle（件数/長さ）で確定する（推奨）
  - 時間差分は最後（短時間・少回数で、他指標と組み合わせる）
  - エラーが見えるなら、構文/参照エラーが返る場合は "DB評価到達" の補助証拠になるが、レポート上は **情報漏えい（例外モデル）** としても扱う
- 何は"言えない"か（不足情報・観測限界）：
  - 具体的な実行結果の断定（内部実装や権限に依存）
  - 高負荷・DoS成立の断定（性能試験は契約・安全性が必要）
  - DBが必ずMongoである断定（互換や抽象化がある）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：ユーザ入力が `$where` キーを直接作れる（構造注入） → クエリ構造を入力にさせている（allowlist不在、スキーマ検証不在）
  - パターンB：既定条件とユーザ条件のマージが危険（同階層 merge / deep merge） → "権限条件" と "検索条件" が同じ構造で扱われ、上書き/混入が起きる
  - パターンC：文字列の "評価機構" に流れている（whereStringを評価） → 機能要件が "評価" を必要としている（設計起因）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・想定パス）
※悪用手順は書かず、ペンテストでの判断軸として整理する。

### 優先度が上がる入口（$where を疑う場所）
- “高度な検索” “条件式” “スクリプト検索” を謳う機能
- 管理者向けのログ閲覧/分析（内部ツールで安易に残りやすい）
- 保存検索・テンプレ（second-order：保存値が後で評価される）
- テナント/所有者条件が暗黙に付与されるAPI（認可境界と衝突しやすい）

### SQLiとの違い（判断のブレを潰す）
- SQLi：DBがSQL構文として解釈
- $where：DBがJS評価として解釈（より危険。まず“禁止”が設計解）
- よって、発見したら “細工して深掘る” より “入口と原因の特定→禁止の提案” を優先する

## 次に試すこと（仮説A/B/C：安全に最小差分で確定）

### 仮説A：入力が `$where` を直接形成できる（構造注入）
- 条件（観測）
  - filter/where にオブジェクト構造が入り、結果（件数/長さ）が安定して変わる
- 次の一手
  - 入口（どのパラメータがクエリ構造へ変換されているか）を固定
  - `$` キーの受理有無を “仕様・バリデータ” として確認（400で落ちるべき）
  - レポートでは「$where混入が可能」だけでなく「なぜ可能か（スキーマ検証不在/直渡し）」を根本原因として書く

### 仮説B：マージ処理が危険で、権限条件と同居している
- 条件（観測）
  - 単純入力では変わらないが、advanced filter で差分が出る
- 次の一手
  - “既定条件” と “ユーザ条件” の合成方法（AND結合か、同階層mergeか）を推定する
  - 認可境界（tenant/org/owner）に関わるフィールド名が、ユーザ入力と同じ階層に存在するかを確認する（越境混入の設計リスク）

### 仮説C：文字列式として受け取った where が評価されている（評価機構）
- 条件（観測）
  - where= のような文字列入力で差分が出る（件数/長さ/遅延）
- 次の一手
  - 仕様として必要なら、安全DSL化（演算子・フィールド allowlist、型拘束、最大複雑度制限）へ
  - 仕様不要なら機能削除（$where禁止）を最優先で提案

## 手を動かす検証（Labs連動：観測点を明確に）
- 目的：$where の危険性を「入口」「合成」「oracle」で再現し、実務での判断を固定する
- 最小構成（推奨）
  - (1) 安全：受理フィールド/型固定、演算子禁止
  - (2) 脆弱：filter JSON を直渡し（$where混入）
  - (3) 脆弱：base条件とuser条件の同階層merge（権限条件と同居）
  - (4) 仕様系：where文字列式を評価（“最悪の例”として）
- 証跡
  - HAR：baseline / 差分true / 差分false
  - サーバログ：trace_id、クエリ構造要約、実行時間
  - DBログ（Labsのみ）：$whereが実際に評価された痕跡

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 危険：汎用filterを直渡し（$where混入が可能）
query = JSON.parse(req.query.filter)
db.collection.find(query)

# 安全：アプリ独自DSLを解釈してクエリ生成（演算子/フィールドallowlist）
input = JSON.parse(req.query.filter)
assert field in allowlist
assert op in allowlist
assert type(value) == expected
query = buildQuery(input)   # サーバで生成（$whereを生成しない）
~~~~

- この例で観測していること：汎用filterの処理方法、allowlistの有無、$whereの混入可能性
- 出力のどこを見るか（注目点）：クエリの生成方法、allowlistの有無、$whereの混入有無
- この例が使えないケース（前提が崩れるケース）：固定数のフィルタのみを使用している場合、または完全に静的なクエリのみを使用している場合

~~~~
# 危険：権限条件とユーザ条件を同階層merge
base = { tenant_id: t }
user = JSON.parse(req.query.filter)
query = { ...base, ...user }     # 同階層で混ぜるのが危険

# 安全：baseは固定、userは安全に生成した条件のみAND結合
query = { $and: [ base, safeUserCondition ] }
~~~~

- この例で観測していること：権限条件とユーザ条件のマージ方法、同階層mergeの危険性
- 出力のどこを見るか（注目点）：マージ処理の方法、AND結合の有無、権限条件の固定性
- この例が使えないケース（前提が崩れるケース）：権限条件が固定されていない場合、または完全に静的なクエリのみを使用している場合

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V5 Validation, Sanitization and Encoding、V7 Error Handling and Logging
  - 該当要件（可能ならID）：V5.3.1、V5.3.2、V7.4.1
  - このファイルの内容が「満たす/破れる」ポイント：
    - 入力→実行境界：ユーザ入力が「DB内のコード評価（JS）」に到達する設計が存在しないか（最優先で排除）
    - 防御の優先順位：ブラックリスト/エスケープではなく **機能無効化・API禁止・allowlist設計** を採用しているか
    - 例外/エラー：$where の構文/実行エラーを返さない（oracle化防止）＋内部例外のログ相関
    - 最小権限：DBユーザ権限・ロール（アプリ側）と、DB設定（サーバ側）で爆発半径を縮める
    - 監査：$where / $function / script を含むクエリの監視、異常頻度・遅延・スキャン傾向の検知
- WSTG：
  - 該当カテゴリ/テスト観点：WSTG-INPV-05 SQL Injection、WSTG-ERRH-01 Error Handling
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：
    - Injection testing として、SQLiの"コード注入"に近い位置づけで扱う（NoSQLiの中でも高危険度）
    - エラー誘発よりも「入力形式→クエリ構造→遅延/件数」の差分観測で成立根拠を取る（安全配慮）
- PTES：
  - 該当フェーズ：Vulnerability Analysis、Exploitation、Reporting
  - 前後フェーズとの繋がり（1行）：入口（filter/where）→クエリ生成点→$where到達条件（成立根拠）→影響（認可境界/DoS）を評価し、影響実証は必要最小限（DoSになりやすいので、過度な遅延や重い条件を避ける）、根本原因を「$whereを許可する設計」「汎用フィルタを直渡し」「機能無効化不足」「監査不足」に分解して提示
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：TA0001 Initial Access（公開アプリ入口）/ TA0009 Collection（条件改変で収集）/ TA0005 Defense Evasion（エラー統一下でブラインド化）
  - 攻撃者の目的（この技術が支える意図）：実装次第で "コード評価" が絡むため、攻撃面としては強い（ただし本リポジトリでは悪用手順ではなく境界モデル化）

## 参考（必要最小限）
- MongoDB Documentation: https://docs.mongodb.com/
- MongoDB $where Operator: https://docs.mongodb.com/manual/reference/operator/query/where/
- OWASP NoSQL Injection: https://owasp.org/www-community/attacks/NoSQL_Injection
- OWASP Injection Prevention Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 深掘りリンク（最大8）
- `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
- `01_topics/02_web/05_input_04_nosql_injection_01_mongodb_01_operator（$ne_$gt_$regex）.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `01_topics/02_web/05_input_04_nosql_injection_01_mongodb_03_aggregation（pipeline_$lookup）.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
