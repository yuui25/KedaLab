# 05_input_04_nosql_injection_03_neo4j_cypher_01_query（cypher_injection）

## 危険性を一言で
- 入力がCypher構文として解釈されると、探索条件や返却範囲が変わる。

## 最小限の成立判断（目安）
- A/B比較で件数やパスの差分が再現できる。

## 観測例（差分のイメージ）
- 期待: 1ノード、差分: 複数ノードが返る。

## 対策の優先順位
1) パラメータ化
2) クエリ構文のallowlist化
3) 権限の最小化

## 目的（この技術で到達する状態）
- Neo4j（Cypher）を使うWeb/APIで、入力が「検索語」ではなく **Cypher構文** として解釈される境界破壊を、
  1) 入口（どの機能がCypherへ到達するか）  
  2) 生成点（文字列連結/テンプレ/OGM）  
  3) 成立根拠（差分＝oracle）  
  4) 影響（認可越境・情報露出・可用性）  
  に分解して評価できるようになる。

## 前提（対象・範囲・想定）
- 対象：グラフ検索（人物/組織/関係検索）、推薦（recommendation）、関連ノード表示、タグ/カテゴリの関係表示、権限グラフ（RBACの関係管理）、"関係の可視化" "つながり" "おすすめ" "共通点" のような機能はCypher到達の可能性が高い
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - アプリ→Neo4j（Bolt/HTTP）、OGM（Object Graph Mapper）やクエリビルダの利用有無でリスクが変わる
  - 本ファイルの焦点：Cypher Injection（クエリ構文境界）＝ **文字列連結でCypherを生成** している場合の問題
  - 非スコープ（別ファイル）：APOC（拡張プロシージャ）由来のリスクは次ファイルで扱う、認可（グラフスコープ）設計は後続の authz ファイルとも接続する
- できること/やらないこと（安全に検証する範囲）：
  - できること：入口（どの機能がCypherへ到達するか）、生成点（文字列連結/テンプレ/OGM）、成立根拠（差分＝oracle）、影響（認可越境・情報露出・可用性）に分解して評価できる
  - やらないこと：影響実証は最小限（越境混入・情報露出の成立まで）。高負荷探索は避ける
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/05_input_03_sql_injection_01_oracle（境界_プレースホルダ_ORM）.md`
  - `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

## 背景：Cypherは“関係を辿る言語”で、越境の形がSQLと異なる
- SQLiは「行/テーブル」の境界を崩す
- Cypherは「ノード/リレーション/パス」を辿り、**一度スコープが崩れると横断収集が容易**
- 実務上の落とし穴
  - “検索機能”として実装したつもりが、実際には “探索機能” をユーザに渡してしまう
  - 返却縮退（properties制御）が弱いと、情報露出が大きくなる

## 境界モデル（入力→Cypher生成→実行→返却）

### 1) 入口（input surface）：Cypher到達点を洗う
- 典型入口（優先度高）
  - 検索：名前/キーワード/タグ/カテゴリ
  - 関連表示：関連ノード、共通の友人、共通の属性
  - 推薦：おすすめ、類似ユーザ、関連コンテンツ
  - 管理：関係の追加/編集（edge作成）
- 観測の取り方（黒箱）
  - 検索語に記号を混ぜたときに、エラー形状・結果の面積が揺れるか
  - 返却に “path” “nodes” “relationships” のような構造が含まれるか（含まれるほど探索性が高い）

### 2) 生成点（sink）：安全/危険の分岐
- 安全側（望ましい）
  - パラメータ化（`$param`）で値だけ渡す
  - クエリは固定テンプレ、入力はパラメータに閉じる
- 危険側（脆弱になりやすい）
  - 文字列連結で `... WHERE n.name = ' + user + ' ...'` のように作る
  - “柔軟な検索”のつもりで、入力が条件式の断片として混ざる
- 典型の実装理由（原因化しやすい）
  - 動的にWHEREを組み立てたい、ソートや条件を自由化したい、という要求
  - OGM/クエリビルダの使い方が分からず、最短で文字列連結に逃げる

### 3) oracle（成立根拠）：エラーよりBoolean差分を主証拠に
- Boolean oracle（主）
  - 件数、レスポンス長、返却ノード数/関係数、特定カテゴリの出現
- Error oracle（補助）
  - Cypher構文エラーが返る場合は、クエリが入力に影響されている補助証拠
  - ただし詳細エラーは情報露出（error model不備）として同時に指摘できる
- Time oracle（補助、DoS配慮）
  - 可変長パス等で遅延が出ることはあるが、負荷検証は避け、制約欠如として扱う

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - 入口（どの機能がCypherへ到達するか）、生成点（文字列連結/テンプレ/OGM）、成立根拠（差分＝oracle）、影響（認可越境・情報露出・可用性）に分解して評価できる
- 何が"推定"できるか（推定の根拠/前提）：
  - まず Boolean oracle（件数/長さ）で確定する（推奨）
  - エラーが見えるなら、Cypher構文エラーが返る場合は、クエリが入力に影響されている補助証拠（ただし詳細エラーは情報露出（error model不備）として同時に指摘できる）
  - 時間差分は最後（短時間・少回数で、他指標と組み合わせる）
- 何は"言えない"か（不足情報・観測限界）：
  - "検索範囲が確実に拡大した"の断定（仕様として高度検索が存在する可能性）、"DoSが可能"の断定（性能試験は別枠、契約と安全配慮が必要）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：検索条件の改変（検索面積が広がる） → 本来：特定ノードだけが返る、境界破壊：条件が変わり、検索範囲が広がる
  - パターンB：グラフ横断（関係の探索で越境混入） → 同一tenant内での関係探索は仕様でも、tenant境界を越えた探索が混入するのが問題
  - パターンC：情報露出（返却プロパティと構造） → グラフは "関係性" が機微になりやすい、返却縮退が弱いと properties の過剰返却、path 全体（nodes+relationships）返却が横断収集の起点になる

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - グラフ検索（人物/組織/関係検索）、推薦（recommendation）、関連ノード表示、タグ/カテゴリの関係表示、権限グラフ（RBACの関係管理）、"関係の可視化" "つながり" "おすすめ" "共通点" のような機能はCypher到達の可能性が高い
- 優先度の付け方（時間制約がある場合の順序）：
  - まず入力の形で結果（件数/返却ノード数/長さ）が安定して揺れる、または構文エラーが揺れるかを確認、入口を確定（どのパラメータがCypher生成に影響するか）
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：入力がCypher構文に混ざっている（Injection） → 入力の形で結果（件数/返却ノード数/長さ）が安定して揺れる、または構文エラーが揺れる
  - 攻め筋2：入力はパラメータだが、スコープ制約や返却縮退が弱い（設計不備） → 構文注入らしい差分はないが、検索面積が過剰・返却が過剰・tenant境界の変化が不自然
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - SQLiと同じ枠で「入力→クエリ生成点→差分観測」で成立根拠を取る、Graph特有の "横断探索" がテナント境界を越えないかを検証観点に入れる

## 典型的な攻撃面（何が起きるか：影響を分解）

### 影響1：検索条件の改変（検索面積が広がる）
- 本来：特定ノードだけが返る
- 境界破壊：条件が変わり、検索範囲が広がる
- 実務の評価
  - “検索機能として許される範囲”を越えるか（仕様との切り分け）
  - 返却が縮退されていない場合、情報露出が拡大する

### 影響2：グラフ横断（関係の探索で越境混入）
- 典型
  - 同一tenant内での関係探索は仕様でも、tenant境界を越えた探索が混入するのが問題
- 重要
  - グラフでは “id 1個” の越境より、**パス探索で段階的に越境** しやすい
- 評価の着眼点
  - “どのノードラベル/リレーション種別”が返るか（スコープ制御の有無）

### 影響3：情報露出（返却プロパティと構造）
- グラフは “関係性” が機微になりやすい
  - 例：同一企業内の組織構造、権限関係、共有関係、取引関係など
- 返却縮退が弱いと
  - properties の過剰返却
  - path 全体（nodes+relationships）返却
  が横断収集の起点になる

### 影響4：可用性（高コスト探索）
- 可変長パス、広いMATCH、正規表現等で高コスト化し得る
- 実務の扱い
  - 実際に高負荷をかけるより、「探索上限・深さ制限・タイムアウト・レート制限」の欠如として評価する

## 根本原因の分類（報告にそのまま使える形）

### 原因A：Cypherのパラメータ化不足（文字列連結）
- 症状
  - 入力の記号で構文エラー/結果差分が揺れる
- 修正
  - 値は必ずパラメータ（`$param`）で渡す
  - “条件/フィールド/ソート”の自由化は、選択式（allowlist）でサーバがクエリを生成する

### 原因B：動的WHERE/ソート/ラベル指定を入力で受けている（語彙の委譲）
- 症状
  - 入力が“値”ではなく“語彙（field/label/order）”として扱われる
- 修正
  - ラベル/プロパティ/ソートキーはサーバ側マッピング（UI選択肢→内部語彙）で固定

### 原因C：スコープ制約（tenant/org/owner）がクエリ構造で揺れる
- 症状
  - tenant条件が入力と同レイヤで合成され、分岐で消える/弱まる
- 修正
  - スコープ制約は常に強制（最外周で固定）し、入力に依存させない

### 原因D：返却縮退（プロパティ制御・パス返却制御）が弱い
- 症状
  - 必要以上のproperties/pathが返る
- 修正
  - 返却フィールドは最小化（DTO/view model）
  - pathを返す場合も深さ・ノード種別・プロパティを制限

## 次に試すこと（仮説A/B：最小差分で確定）
※具体の悪用payloadは示さず、観測設計として書く。

### 仮説A：入力がCypher構文に混ざっている（Injection）
- 条件（観測）
  - 入力の形で結果（件数/返却ノード数/長さ）が安定して揺れる、または構文エラーが揺れる
- 次の一手
  - 入口を確定（どのパラメータがCypher生成に影響するか）
  - 同一入口で再現性を取り、WAFやエラーモデルの影響を除外して“成立根拠”を固める

### 仮説B：入力はパラメータだが、スコープ制約や返却縮退が弱い（設計不備）
- 条件（観測）
  - 構文注入らしい差分はないが、検索面積が過剰・返却が過剰・tenant境界の変化が不自然
- 次の一手
  - 認可（スコープ）と返却縮退を中心に、BOLA/BFLAの観点で評価を組み立てる（Cypher injectionとは別軸で報告）

## 防御設計（実装・運用）

### 1) パラメータ化（最優先）
- クエリ本文に入力を連結しない
- 値は `$param` で渡す
- 動的条件は “サーバ側で構造生成” し、入力は選択肢に限定する

### 2) allowlist（語彙の固定）
- 許可する
  - プロパティ（検索対象フィールド）
  - ラベル/リレーション種別
  - ソートキー
  をサーバ側で固定（マッピング）
- 入力に “語彙” を渡さない（値だけ渡す）

### 3) スコープ制約（tenant/org/owner）の強制
- 常に最外周で固定し、入力に依存させない
- グラフ探索（可変長）を許可する場合
  - 深さ上限（max depth）
  - 許可ラベル/関係の制限
  - tenant境界を跨ぐエッジをそもそも作らない（データモデル側の設計）
  をセットで持つ

### 4) 返却縮退（DTO/view model）
- 必要なプロパティだけ返す
- pathを返す場合も
  - 深さ、ノード種別、関係種別、プロパティ を制限
- “探索API” と “参照API” を分離し、探索側は権限と監査を強くする

### 5) 可用性（制限）
- タイムアウト、結果上限、レート制限
- 可変長パスや正規表現の利用を制限（必要なら管理者専用など）

### 6) エラーモデル統一
- 外部：統一エラー + trace_id
- 内部：Cypherの構文/実行エラーを分類し、原因追跡できるログ（ただし入力はマスク）

## 手を動かす検証（Labs連動：Cypher境界の再現）
- 目的：文字列連結 vs パラメータ化、スコープ強制の有無を比較し、差分観測で成立根拠を取る
- 最小構成（推奨）
  - (1) 安全：クエリ固定 + paramsのみ + tenant強制 + 返却縮退
  - (2) 危険：文字列連結でWHEREを生成（悪い例）
  - (3) スコープ不備：tenant条件が分岐で消える悪い例
  - (4) 返却過剰：path/propertiesを返し過ぎる悪い例
- 証跡
  - HAR：baseline / 差分（件数・構造） / 差分（エラー）
  - サーバログ：trace_id、利用したクエリテンプレID、paramsの型、実行時間
  - DB側（Labsのみ）：クエリログ、計画、タイムアウト

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 安全：paramsで値だけ渡す（概念例）

MATCH (n:User)
WHERE n.email = $email AND n.tenant_id = $tenant
RETURN n.id, n.name
~~~~

- この例で観測していること：入力が構文に混ざらず、スコープ（tenant）が固定で強制される設計
- 出力のどこを見るか（注目点）：パラメータ化の有無、スコープ条件の固定性、返却フィールドの縮退
- この例が使えないケース（前提が崩れるケース）：ソートやフィールド選択を動的にしたい場合も、語彙はallowlist化してサーバがクエリを生成する必要がある

~~~~
# 危険（概念）：文字列連結でWHERE等を組み立てる設計はInjection境界が開くため禁止

# ※具体の悪用payloadは提示しない

~~~~

- この例で観測していること：文字列連結でCypherを生成している危険な設計
- 出力のどこを見るか（注目点）：入力の記号で構文エラー/結果差分が揺れる、入力の形で結果（件数/返却ノード数/長さ）が安定して揺れる
- この例が使えないケース（前提が崩れるケース）：パラメータ化が正しく実装されている場合、または完全に静的なクエリのみを使用している場合

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V5 Validation, Sanitization and Encoding、V7 Error Handling and Logging
  - 該当要件（可能ならID）：V5.3.1、V5.3.2、V7.4.1
  - このファイルの内容が「満たす/破れる」ポイント：
    - 入力→実行境界：ユーザ入力が "値" ではなく **Cypherクエリ（構文）** の一部として解釈されない設計か（パラメータ化必須）
    - 認可境界：グラフ探索は「関係（edge）」を辿るため、IDOR/BOLAと違う形で越境する（ノード/リレーションのスコープ強制が必要）
    - データ公開：返却フィールド（properties）とパス（path）を縮退しないと、探索で横断収集しやすい
    - エラーモデル：構文エラーがスタックやクエリ断片を返すとoracleになる（実装露出）
    - 可用性：可変長パス、広いマッチ、正規表現等が高コストになり得る（制限設計が必要）
- WSTG：
  - 該当カテゴリ/テスト観点：WSTG-INPV-05 SQL Injection、WSTG-ERRH-01 Error Handling
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：
    - Injection：SQLiと同じ枠で「入力→クエリ生成点→差分観測」で成立根拠を取る
    - Authorization：Graph特有の "横断探索" がテナント境界を越えないかを検証観点に入れる
- PTES：
  - 該当フェーズ：Vulnerability Analysis、Exploitation、Reporting
  - 前後フェーズとの繋がり（1行）：Cypher生成点（文字列連結/テンプレ/OGM）と入口（検索/推薦/関係表示）を特定し、影響実証は最小限（越境混入・情報露出の成立まで）。高負荷探索は避ける、原因を「パラメータ化不足」「OGM/テンプレ誤用」「スコープ制約不在」「返却縮退不足」「制限不備」に分解して提示
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：TA0009 Collection（グラフは横断収集と相性が良い）/ TA0001 Initial Access（公開API入口）
  - 攻撃者の目的（この技術が支える意図）：T1190（公開アプリのExploit）、探索により関係性情報を収集

## 参考（必要最小限）
- Neo4j Docs：Cypher manual（パラメータ、クエリ構造）  
  - https://neo4j.com/docs/cypher-manual/current/
- Neo4j Docs：Drivers and parameterized queries（パラメータ化の基本）  
  - https://neo4j.com/docs/
  （※ドライバ/言語別ページは環境により異なるため、実装言語に合わせて参照）
- Neo4j Docs：Security（運用・権限）  
  - https://neo4j.com/docs/operations-manual/current/security/

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 深掘りリンク（最大8）
- `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
- `01_topics/02_web/05_input_03_sql_injection_01_oracle（境界_プレースホルダ_ORM）.md`
- `01_topics/02_web/05_input_04_nosql_injection_03_neo4j_cypher_02_apoc（procedure_security）.md`
- `01_topics/02_web/05_input_04_nosql_injection_03_neo4j_cypher_03_authz（graph_traversal_scope）.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
