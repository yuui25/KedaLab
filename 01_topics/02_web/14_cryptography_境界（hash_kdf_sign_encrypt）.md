# 14_cryptography_境界（hash_kdf_sign_encrypt）

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
「何を守りたいか」からプリミティブを選び、鍵・検証・失効・ログまでを"運用できる境界"に落とす

---

## 目的（この技術で到達する状態）
- Web実装で頻出の暗号用途（パスワード、トークン、署名、機微DB、署名付きURL、Webhook）について、境界モデルとして説明できる：
  - どのプリミティブを使うべきか（hash/KDF/MAC/sign/encrypt）
  - どこで検証するべきか（Edge/BFF/API/Worker）
  - 鍵・salt・nonce/IV・乱数をどう扱うべきか
  - 失効・ローテーション・監査ログをどう組み込むべきか
- 診断・レビューでは、暗号"アルゴリズム名当て"ではなく、最短で見つけ、次の一手（是正案）へ落とせる：
  - 「用途のズレ（hashで隠したつもり、encryptすべきだった等）」
  - 「検証点の欠落（署名しているが検証していない/条件が甘い）」
  - 「鍵運用の欠陥（固定鍵、共有鍵、ローテーション不能、ログ混入）」
  - 「乱数/nonce/IV/saltの誤用」

## 前提（対象・範囲・想定）
- 対象：Web実装で頻出の暗号用途（パスワード、トークン、署名、機微DB、署名付きURL、Webhook）
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - Edge/BFF/API/Worker等の検証ポイント
  - KMS/HSM等の鍵管理基盤
  - 暗号ライブラリの利用環境
- できること/やらないこと（安全に検証する範囲）：
  - できる：許可されたスコープ内での観測（暗号実装の確認）、検証点の確認
  - やらない：実際の暗号攻撃、許可されていない対象への検証
- 依存する前提知識（必要最小限）：
  - 暗号の基本概念（hash/KDF/MAC/sign/encrypt）、鍵管理の基本、検証の基本
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：
    - hash（ハッシュ）とKDF（パスワードハッシュ/鍵導出）
    - sign/MAC（署名・完全性）とencrypt（機密性）
    - nonce/IV/salt/乱数、鍵管理（保管・ローテ・権限分離）、検証点（aud/iss/kid等）
    - Webに典型の"暗号の接続点"（JWT/JWS、Cookie、署名付きURL、Webhook署名、DB暗号化）
  - 扱わない（別ユニットへ接続）：
    - TLSの詳細 → `01_topics/01_asm-osint/02_tls_証明書・CT・外部依存推定.md`
    - Secrets管理の一般 → `01_topics/02_web/06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
    - セッション/トークン設計の全体 → `02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`

---


## まず結論：用途→プリミティブ対応表（迷いをなくす）
### 1) hash（ハッシュ）
- 目的：復元不能の要約、同一性比較、改ざん検出の部品（ただし単体では“鍵なし”）
- 使いどころ
  - パスワード保存の“素材”としては不可（必ずKDFへ）
  - “トークンの生値をログやDBに残したくない”場合の参照（ハッシュ化して突合）
- 使ってはいけない誤用
  - 「hashしたから暗号化した」扱い（機密性は得られない）
  - 速いハッシュでパスワード保存（総当たりに弱い）

### 2) KDF（Key Derivation Function / Password Hash）
- 目的：パスワードや低エントロピーの秘密から、総当たりに強い形で保存/導出する
- 使いどころ
  - パスワードハッシュ（推奨：Argon2 / bcrypt / scrypt、要件次第でPBKDF2）
  - “秘密鍵をパスワードから作る”場合の導出（ただし設計的に避けられるなら避ける）
- 必須要素
  - salt（ユニーク）と適切なコスト（time/memory）
  - パラメータの記録（後から上げられる形）

### 3) MAC（HMAC 等：共有鍵の完全性）
- 目的：改ざん検知と正当性（鍵共有している主体のみ生成可能）
- 使いどころ
  - Webhook署名（送信側と受信側で秘密共有）
  - 署名付きURL/署名付きCookie（ただし運用要件次第）
- 注意
  - 鍵漏えい＝偽造可能（影響半径が大きいので鍵運用が主戦場）

### 4) sign（公開鍵署名：非対称鍵）
- 目的：改ざん検知と正当性（秘密鍵で署名、公開鍵で検証）
- 使いどころ
  - IdP発行トークン（OIDC/SAML署名）
  - サービス間で「検証者が多い」「秘密を配れない」場合
- 注意
  - 鍵選択（kid）・鍵配布（JWKS）・ローテーションの設計が必須

### 5) encrypt（暗号化）
- 目的：機密性（読めない）＋（推奨は）完全性（AEADで同時に確保）
- 使いどころ
  - DBの機微カラム暗号化（アプリ層/DB層/Envelope）
  - トークンを“見せたくない”場合（JWE等。ただし設計コストが高い）
- 注意
  - 「暗号化したが改ざん検知がない」は危険（原則AEAD）
  - nonce/IV再利用は破滅的になり得るため、生成と管理が最重要

---

## 乱数・salt・nonce/IV：暗号の“土台”が壊れる典型
### 1) salt（KDF/パスワードハッシュ）
- 目的
  - 同じパスワードでもハッシュが同じにならない（レインボーテーブル耐性）
  - ユーザ単位の総当たりを分散させる
- 要件
  - ユニーク（ユーザごと）
  - 秘密ではない（隠す必要はない）
- よくある失敗
  - 固定salt、短すぎるsalt、saltがない

### 2) nonce/IV（暗号化・AEAD）
- 目的
  - 同じ平文でも暗号文が変わる（パターン漏えい防止）
  - AEADではnonce再利用が致命傷になる場合がある
- 要件
  - “同一鍵”で再利用しない（方式の要件に従う）
  - 生成をアプリ任せにするなら、衝突しない設計（カウンタ/乱数/組合せ）を持つ
- よくある失敗
  - 固定IV、短いIV、同一nonce再利用、再試行でnonce使い回し

### 3) 乱数（トークン、リセット、署名付きURL）
- 目的
  - 推測不能性（予測されると“暗号を使っていても終わる”）
- 要件
  - CSPRNG（暗号学的に安全な乱数）
  - 期限（exp）と一回性（jti/DBで消し込み）の組み合わせ
- よくある失敗
  - 時刻や連番由来、短いトークン、期限なし、再利用可能

---

## Webで頻出の“暗号の接続点”別：設計の定石と境界
### 1) パスワード保存（hashではなくKDF）
- 定石
  - パスワードは“復元不能”が要件：KDF（password hash）を使う
  - saltはユニーク、コストは現実的に高く（運用可能な範囲で）
  - パラメータを将来上げられる（ログイン時に再ハッシュ移行など）
- 境界（どこで何を信じるか）
  - 入力値の比較は定数時間比較（タイミング差の最小化）
  - ログ/監視にパスワード・ハッシュ原文・リセットトークンを出さない
- 代表的な失敗
  - SHA系で保存、固定salt、コストが低すぎ、平文ログ混入

### 2) パスワードリセット・回復（tokenの設計）
- 定石
  - “短寿命 + 一回性 + スコープ限定（この操作だけ）”
  - tokenの生値をDBに保存しない（保存するならtoken_hash）
  - 使用後は即失効（ワンタイム）
- 境界
  - “回復”は認証より弱くなりやすい：本人確認と失効が最重要
  - 監査ログ（誰に発行したか、IP/UA、成功/失敗）を残す

### 3) セッションCookie（署名/暗号化の誤用に注意）
- パターンA：サーバ側セッション（推奨になりやすい）
  - CookieはランダムなセッションIDのみ（中身はサーバ）
  - 暗号はCookieに詰めない設計で回避できる
- パターンB：ステートレスCookie（中身を持つ）
  - “改ざん検知（MAC/署名）”が必須
  - 機微情報を入れるなら暗号化（ただし鍵運用が重くなる）
- 境界
  - cookieの属性（Secure/HttpOnly/SameSite等）と一体で成立
  - セッション再利用（replay）検知は別ファイル側と接続：`13_session_replay_再利用と検知（ua_ip_binding）.md`

### 4) JWT/JWS（signの典型：検証が設計の本体）
- 定石（検証点の必須）
  - 署名検証：アルゴリズム固定、鍵選択の制御
  - クレーム検証：iss/aud/exp/nbf/i-at（必要なら）/nonce（文脈次第）
  - スコープ検証：scope/role/tenant等を“どこまで信じるか”を固定
- 境界（ありがちな崩れ）
  - “署名は検証しているがaudを見ていない” → 別用途トークンの流用
  - “issが曖昧” → 別発行者を受理
  - “kidを盲信” → 鍵選択が攻撃者入力になる（運用・実装次第で危険）
  - “失効戦略がない” → 漏えい時の影響が長い

### 5) Webhook署名（MAC/HMACが典型）
- 定石
  - 署名は“ボディ全体 + タイムスタンプ + リプレイ耐性”が基本
  - 受信側は “許容時刻差（clock skew）” を持ちながら一回性を担保（event_id等）
  - 共有鍵は最小権限・ローテーション可能に
- 境界
  - 署名検証を“受信直後”に行い、検証前に副作用を起こさない
  - 失敗時のログは機微を残さず、相関IDで追えるようにする（`11_logging_tracing_相関IDと証跡設計.md`）

### 6) 署名付きURL（download/upload、期限付きアクセス）
- 定石
  - 期限（exp）＋スコープ（path/object）＋メソッド（GET/PUT）を署名対象に含める
  - 署名の検証点を統一（CDN/アプリ/ストレージ）
- 境界
  - “署名はあるが対象が広い（prefix全体等）” → 逸脱利用の余地
  - “期限が長い” → 漏えい時の被害が大きい
  - “ログにURLを丸ごと残す” → 署名/トークンが漏れる（二次被害）

### 7) DB機微カラム暗号化（encrypt：運用が本体）
- 方式選択（境界の置き方）
  - アプリ層暗号化：アプリが鍵を持つ（権限境界が明確、実装コストあり）
  - DB機能暗号化：DBが鍵を持つ（運用容易だが権限分離に注意）
  - Envelope暗号化：データ鍵（DEK）をKMSで保護（鍵ローテが扱いやすい）
- 境界
  - 検索・ソート・部分一致が必要なら、暗号化方式と要件が衝突する（安易に“検索も暗号化も”を同時に満たそうとすると危険な設計に寄る）
  - 鍵アクセス権＝機微閲覧権。監査・最小権限・分離が必要

---

## 鍵管理（Key Management）：暗号の強度は“鍵の運用”で決まる
### 1) 鍵の所在（どこに置くか）
- 望ましい方向
  - コードに埋めない
  - 設定ファイル平文を避ける（少なくともアクセス制御・監査を前提）
  - KMS/HSM等で保護し、利用権限を最小化
- 境界（実務の落とし穴）
  - “アプリが復号できる”＝“侵害時に復号される”
  - よって、侵害時の影響半径をどう抑えるか（キー分割、テナント別鍵、用途別鍵）が設計要件になる

### 2) 用途別鍵（Key Separation）
- 1本の鍵で全部やらない
  - パスワードハッシュ（KDF）と、HMAC署名と、暗号化は別鍵・別用途
- 理由
  - 漏えい時の影響半径が小さくなる
  - ローテーションがやりやすい（用途単位で回せる）

### 3) ローテーション（Rotation）を“最初から”設計する
- 署名鍵（sign/MAC）
  - 複数鍵の同時受理（検証は旧鍵もOK）→ 発行は新鍵のみ → 期限後に旧鍵破棄
- 暗号化鍵（encrypt）
  - 既存データの再暗号化が必要になる可能性（運用コスト）
  - Envelope暗号化で負担を軽減する設計が現実的になりやすい
- 境界
  - “ローテができない暗号”は、漏えい時に全データ/全トークンが全損になりやすい

### 4) 鍵ID（kid）と鍵選択
- 方針
  - kidは便利だが、入力に引っ張られると危険になり得る
  - 信頼できる鍵セット（許可リスト）からしか選ばない
- 運用
  - kidの命名規則（用途/環境/発行者/世代）を固定し、ログに“どの鍵で検証したか”を残す（機微そのものは残さない）

---

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - 暗号プリミティブ：hash（ハッシュ）、KDF（パスワードハッシュ/鍵導出）、MAC（HMAC等：共有鍵の完全性）、sign（公開鍵署名：非対称鍵）、encrypt（暗号化：機密性）
  - 暗号で守る4種類の性質：機密性（Confidentiality：第三者に見えない）、完全性（Integrity：改ざんされていない）、正当性（Authenticity：正しい主体が作った）、耐再現性（Replay resistance：使い回しが効かない）
  - 乱数・salt・nonce/IV：salt（KDF/パスワードハッシュ：ユニーク、秘密ではない）、nonce/IV（暗号化・AEAD："同一鍵"で再利用しない）、乱数（トークン、リセット、署名付きURL：CSPRNG（暗号学的に安全な乱数））
  - 鍵管理：鍵の所在（コード/設定/Secrets/KMS）、用途別鍵（Key Separation：1本の鍵で全部やらない）、ローテーション（Rotation：複数鍵の同時受理→発行は新鍵のみ→期限後に旧鍵破棄）、鍵ID（kid）と鍵選択（信頼できる鍵セット（許可リスト）からしか選ばない）
  - 検証点：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されているか（受理条件の明文化）、鍵選択（kid）の制御
  - Webに典型の"暗号の接続点"：JWT/JWS（signの典型：検証が設計の本体）、Webhook署名（MAC/HMACが典型）、署名付きURL（download/upload、期限付きアクセス）、DB機微カラム暗号化（encrypt：運用が本体）
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：
    - パスワード、トークン、鍵、個人情報、機密設定、署名検証点
    - パスワード保存（hashではなくKDF）、パスワードリセット・回復（tokenの設計）、セッションCookie（署名/暗号化の誤用に注意）、JWT/JWS（signの典型：検証が設計の本体）、Webhook署名（MAC/HMACが典型）、署名付きURL（download/upload、期限付きアクセス）、DB機微カラム暗号化（encrypt：運用が本体）
  - 信頼境界（外部連携・第三者・越境ポイント）：
    - 何を信じるか（Trust）：署名されたclaimsでも、用途（aud）や発行者（iss）や鍵選択（kid）を誤ると信頼は崩れる
    - 鍵の所在：コードに埋めない、設定ファイル平文を避ける（少なくともアクセス制御・監査を前提）、KMS/HSM等で保護し、利用権限を最小化
    - "アプリが復号できる"＝"侵害時に復号される"、よって、侵害時の影響半径をどう抑えるか（キー分割、テナント別鍵、用途別鍵）が設計要件になる
  - 権限境界（権限の切替/伝播/委任）：
    - どこで検証するべきか（Edge/BFF/API/Worker）
    - 検証点の欠落（署名している≠検証している）：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されているか（受理条件の明文化）
    - 鍵アクセス権＝機微閲覧権。監査・最小権限・分離が必要
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - 用途とプリミティブの整合："用途のズレ（hashで隠したつもり、encryptすべきだった等）"、パスワード保存にhashを使っていないか、機密データをMACだけで守っていないか（読めてしまう）、暗号化しているが改ざん検知がない（AEADでない等）
  - 検証点の欠落：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されているか（受理条件の明文化）、検証不足は"偽造ではなく流用"で破られやすい（境界の崩壊）
  - 乱数・salt・nonce/IVの適切性：saltがユニークか、KDFのコストが十分か、nonce/IVが固定・再利用されていないか、トークンが短すぎないか、期限があるか、一回性があるか
  - 鍵運用の成立：鍵がどこにあるか（コード/設定/Secrets/KMS）、ローテーションできるか（複数鍵受理、鍵世代管理）、監査ログ（鍵利用の痕跡）があるか、鍵漏えい時の影響半径と復旧可能性（回せるか）が決まる
  - ログに秘密が出ていないか（暗号の逆流）：Authorization、署名付きURL、Webhook署名、リセットトークン、暗号文/平文の出力、ログが"攻撃者の宝庫"になっていると、暗号境界が別経路で崩れる

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - 用途とプリミティブが合っているか（パスワード保存にhashを使っていないか、機密データをMACだけで守っていないか、暗号化しているが改ざん検知がない（AEADでない等））
  - 検証点が正しいか（署名検証がどこで行われるか、iss/aud/exp等が検証されているか）
  - 乱数・salt・nonce/IVが適切か（saltがユニークか、KDFのコストが十分か、nonce/IVが固定・再利用されていないか、トークンが短すぎないか、期限があるか、一回性があるか）
  - 鍵運用が成立しているか（鍵がどこにあるか、ローテーションできるか、監査ログ（鍵利用の痕跡）があるか）
  - ログに秘密が出ていないか（Authorization、署名付きURL、Webhook署名、リセットトークン、暗号文/平文の出力）
- 何が"推定"できるか（推定の根拠/前提）：
  - 目的（機密性/完全性/正当性/耐再現性）に対し不足がある（用途とプリミティブが合っていない場合）
  - 検証不足は"偽造ではなく流用"で破られやすい（境界の崩壊）
  - 土台が崩れると暗号の種類を変えても意味がない（乱数・salt・nonce/IVが適切でない場合）
  - 鍵漏えい時の影響半径と復旧可能性（回せるか）が決まる（鍵運用が成立していない場合）
  - ログが"攻撃者の宝庫"になっていると、暗号境界が別経路で崩れる（ログに秘密が出ている場合）
- 何は"言えない"か（不足情報・観測限界）：
  - 実際の暗号攻撃の成功の有無（観測だけでは確定できない）
  - 鍵漏えいの実際の発生率（鍵運用の実際の安全性）
  - 暗号実装の実際の強度（アルゴリズムの選択と実装品質）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：用途とプリミティブが適切に選択されている
    - 正常：守りたい性質（機密性/完全性/正当性/耐再現性）に対し適切なプリミティブが選択されている
  - パターンB："hash＝暗号化"と誤認し、機密情報をハッシュで隠そうとする
    - 異常：用途のズレ（hashで隠したつもり、encryptすべきだった等）
  - パターンC：パスワードを高速ハッシュで保存（総当たりに弱い）
    - 異常：用途のズレ（hashではなくKDFを使うべき）
  - パターンD：署名はあるが aud/iss/exp の検証が甘く、用途違いトークンが通る
    - 異常：検証点の欠落（署名している≠検証している）
  - パターンE：kid/鍵選択が入力に引っ張られ、許可されない鍵で検証される余地がある
    - 異常：検証点の欠落（鍵選択の制御が不適切）
  - パターンF：暗号化しているが改ざん検知がなく、復号後の処理が危険（AEAD不使用）
    - 異常：用途のズレ（encryptだけでなく、完全性も確保すべき）
  - パターンG：nonce/IVの再利用（再試行や並列処理で起きやすい）
    - 異常：乱数・salt・nonce/IVの誤用
  - パターンH：固定鍵・共有鍵で全環境/全顧客を守り、漏えい時に全損
    - 異常：鍵運用の欠陥（固定鍵、共有鍵、ローテーション不能、ログ混入）
  - パターンI：ログ/例外/デバッグにトークンや秘密が混入（暗号の努力が無効化）
    - 異常：ログに秘密が出ている（暗号の逆流）
  - パターンJ：失効・ローテーションの設計がなく、漏えい時に止められない
    - 境界がズレている：鍵運用の欠陥（ローテーション不能）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - 用途のズレ（hashで隠したつもり、encryptすべきだった等）：機密情報をハッシュで隠そうとする、機密データをMACだけで守っている（読めてしまう）、暗号化しているが改ざん検知がない（AEADでない等）
  - 検証点の欠落（署名している≠検証している）：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されていない、kid/鍵選択が入力に引っ張られ、許可されない鍵で検証される余地がある
  - 鍵運用の欠陥：固定鍵、共有鍵、ローテーション不能、ログ混入、失効・ローテーションの設計がなく、漏えい時に止められない
  - 乱数・salt・nonce/IVの誤用：saltが固定、コストが低い、パラメータが保存されず将来上げられない、nonce/IVの再利用（再試行や並列処理で起きやすい）、トークンが短すぎないか、期限があるか、一回性があるか
- 優先度の付け方（時間制約がある場合の順序）：
  1. 用途とプリミティブが合っているか（パスワード保存にhashを使っていないか、機密データをMACだけで守っていないか、暗号化しているが改ざん検知がない（AEADでない等））の確認
  2. 検証点が正しいか（署名検証がどこで行われるか、iss/aud/exp等が検証されているか）の確認
  3. 鍵運用が成立しているか（鍵がどこにあるか、ローテーションできるか、監査ログ（鍵利用の痕跡）があるか）の確認
  4. 乱数・salt・nonce/IVが適切か（saltがユニークか、KDFのコストが十分か、nonce/IVが固定・再利用されていないか）の確認
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：用途のズレ（hashで隠したつもり、encryptすべきだった等）
    - 成立条件：機密情報をハッシュで隠そうとする、機密データをMACだけで守っている（読めてしまう）、暗号化しているが改ざん検知がない（AEADでない等）
    - 結果：目的（機密性/完全性/正当性/耐再現性）に対し不足がある
  - 攻め筋2：検証点の欠落（署名している≠検証している）
    - 成立条件：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されていない、kid/鍵選択が入力に引っ張られ、許可されない鍵で検証される余地がある
    - 結果：検証不足は"偽造ではなく流用"で破られやすい（境界の崩壊）
  - 攻め筋3：鍵運用の欠陥
    - 成立条件：固定鍵、共有鍵、ローテーション不能、ログ混入、失効・ローテーションの設計がなく、漏えい時に止められない
    - 結果：鍵漏えい時の影響半径と復旧可能性（回せるか）が決まる
  - 攻め筋4：乱数・salt・nonce/IVの誤用
    - 成立条件：saltが固定、コストが低い、パラメータが保存されず将来上げられない、nonce/IVの再利用（再試行や並列処理で起きやすい）、トークンが短すぎないか、期限があるか、一回性があるか
    - 結果：土台が崩れると暗号の種類を変えても意味がない
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - 用途とプリミティブが合っていない場合：目的を再定義し、プリミティブを差し替える（例：hash→KDF、encrypt→AEAD、MAC追加など）
  - 検証点の欠落がある場合：検証チェックリストを固定し、判定点（Policy/Guard）へ寄せる
  - 鍵運用が弱い場合：用途別鍵＋ローテーション計画＋最小権限（アクセス制御）を設計要件に入れる

## 次に試すこと（仮説A/Bの分岐と検証）
> ここが最重要。条件が違うと次の手が変わる形で書く。

- 仮説A：用途の選択ミス（hash/KDF/sign/encryptの取り違え）
  - 成立条件：パスワード保存にhashを使っている、機密データをMACだけで守っている（読めてしまう）、暗号化しているが改ざん検知がない（AEADでない等）
  - 次の検証：
    1) 守りたい性質（機密性/完全性/正当性/耐再現性）を明文化し、プリミティブを再配置
    2) 例：パスワード→KDF、機密DB→AEAD、Webhook→HMAC、IdP→署名検証厳格化
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功：守りたい性質（機密性/完全性/正当性/耐再現性）に対し適切なプリミティブが選択されている
    - 失敗：目的（機密性/完全性/正当性/耐再現性）に対し不足がある
- 仮説B：検証点の欠落（署名しているが境界で検証していない/条件が甘い）
  - 成立条件：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されていない、kid/鍵選択が入力に引っ張られ、許可されない鍵で検証される余地がある
  - 次の検証：
    1) 入口（Gateway/BFF/API）での検証責務を固定
    2) クレーム検証（iss/aud/exp等）と鍵許可リストを仕様化
    3) 監査ログに「検証成功/失敗」「理由（要約）」を残す（機微は残さない）
  - 期待する観測：
    - 成功：検証チェックリストを固定し、判定点（Policy/Guard）へ寄せる
    - 失敗：検証不足は"偽造ではなく流用"で破られやすい（境界の崩壊）
- 仮説C：鍵運用が弱い（固定鍵、ローテ不能、漏えい時に止められない）
  - 成立条件：固定鍵、共有鍵、ローテーション不能、ログ混入、失効・ローテーションの設計がなく、漏えい時に止められない
  - 次の検証：
    1) 用途別鍵、環境別鍵、可能ならテナント別鍵へ分離
    2) ローテーション計画（多鍵受理→移行→旧鍵破棄）
    3) KMS等の導入、最小権限、監査ログの整備
  - 期待する観測：
    - 成功：鍵漏えい時の影響半径と復旧可能性（回せるか）が決まる
    - 失敗：固定鍵・共有鍵で全環境/全顧客を守り、漏えい時に全損
- 仮説D：乱数/nonce/IV/salt が弱い（構造的に破綻）
  - 成立条件：saltが固定、コストが低い、パラメータが保存されず将来上げられない、nonce/IVの再利用（再試行や並列処理で起きやすい）、トークンが短すぎないか、期限があるか、一回性があるか
  - 次の検証：
    1) アプリ独自生成を減らし、標準ライブラリへ寄せる
    2) 方式要件に沿ってnonce再利用が起きない設計（並列/再試行を含めて）へ修正
    3) トークンは短寿命＋一回性＋スコープ限定へ
  - 期待する観測：
    - 成功：土台が崩れると暗号の種類を変えても意味がない、生成をライブラリ標準に寄せ、アプリ独自生成を減らす（設計の簡素化）
    - 失敗：nonce/IVの再利用（再試行や並列処理で起きやすい）

---

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/02_web/14_crypto_01_password_hashing_kdf_parameters/`（候補）
    - `04_labs/02_web/14_crypto_02_signature_verification_claims_boundary/`（候補）
    - `04_labs/02_web/14_crypto_03_webhook_hmac_timestamp_replay/`（候補）
    - `04_labs/02_web/14_crypto_04_aead_nonce_iv_management_parallel_retry/`（候補）
    - `04_labs/02_web/14_crypto_05_key_rotation_multi_key_acceptance/`（候補）
- 取得する証跡（目的ベースで最小限）：
  - 暗号プリミティブの選択：hash/KDF/MAC/sign/encryptの使用箇所
  - 検証点：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されているか（受理条件の明文化）
  - 鍵管理：鍵がどこにあるか（コード/設定/Secrets/KMS）、ローテーションできるか（複数鍵受理、鍵世代管理）、監査ログ（鍵利用の痕跡）があるか
  - 乱数・salt・nonce/IV：saltがユニークか、KDFのコストが十分か、nonce/IVが固定・再利用されていないか、トークンが短すぎないか、期限があるか、一回性があるか
  - ログ：Authorization、署名付きURL、Webhook署名、リセットトークン、暗号文/平文の出力
- 観測の取り方（どの視点で差分を見るか）：
  - "用途とプリミティブが合っているか"：パスワード保存にhashを使っていないか、機密データをMACだけで守っていないか（読めてしまう）、暗号化しているが改ざん検知がない（AEADでない等）
  - "検証点が正しいか"（署名している≠検証している）：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されているか（受理条件の明文化）
  - "乱数・salt・nonce/IVが適切か"：saltがユニークか、KDFのコストが十分か、nonce/IVが固定・再利用されていないか、トークンが短すぎないか、期限があるか、一回性があるか
  - "鍵運用が成立しているか"：鍵がどこにあるか（コード/設定/Secrets/KMS）、ローテーションできるか（複数鍵受理、鍵世代管理）、監査ログ（鍵利用の痕跡）があるか
  - "ログに秘密が出ていないか"（暗号の逆流）：Authorization、署名付きURL、Webhook署名、リセットトークン、暗号文/平文の出力
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/cryptography 2>/dev/null
    cd ~/keda_evidence/cryptography
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **代表点の抽出** のみ（全機能を網羅しない）
      - 実際の暗号攻撃は **行わない**（目的は観測であり、攻撃ではない）
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host（対象ドメイン）
    - Path（対象パス）
    - Time（観測時刻）
    - Primitive-Type（暗号プリミティブ：hash/KDF/MAC/sign/encrypt）
    - Purpose（用途：機密性/完全性/正当性/耐再現性）
    - Verification-Point（検証点：入口/各サービス/一部だけ）
    - Key-Location（鍵の所在：コード/設定/Secrets/KMS）
    - Key-Rotation（ローテーション：可能/不可能）
    - Salt-Unique（saltがユニークか）
    - Nonce-IV-Reuse（nonce/IVの再利用：有/無）
    - Log-Secrets（ログに秘密が出ているか：有/無）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 目的：

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
# - 「暗号を使っている」ではなく「境界として成立している」を確認する

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
# - どのプリミティブで何を守り、どこで検証し、鍵をどう回すかまでを仕様化する

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿

# 典型の"仕様として固定すべき項目"（例）

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
# - password: KDF=Argon2id/bcrypt/scrypt/PBKDF2, salt unique, params stored, upgrade plan

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
# - token(JWS): alg fixed, key allowlist, iss/aud/exp required, clock-skew policy

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
# - webhook(HMAC): body+timestamp signed, replay protection, secret rotation

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
# - encrypt(AEAD): nonce/IV policy, key separation, envelope encryption, rotation approach

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
# - logging: secrets redaction, token hashing (jti/hashed), audit decision+reason+trace_id

## 基本概念の要約
- hash: 一方向変換
- kdf: 鍵導出
- sign: 改ざん検知
- encrypt: 秘匿
~~~~

- この例で観測していること：
  - 「暗号を使っている」ではなく「境界として成立している」を確認する
  - どのプリミティブで何を守り、どこで検証し、鍵をどう回すかまでを仕様化する
- 出力のどこを見るか（注目点）：
  - 暗号プリミティブの選択：hash/KDF/MAC/sign/encryptの使用箇所
  - 検証点：署名検証がどこで行われるか（入口/各サービス/一部だけ）、iss/aud/exp等が検証されているか（受理条件の明文化）
  - 鍵管理：鍵がどこにあるか（コード/設定/Secrets/KMS）、ローテーションできるか（複数鍵受理、鍵世代管理）、監査ログ（鍵利用の痕跡）があるか
  - 乱数・salt・nonce/IV：saltがユニークか、KDFのコストが十分か、nonce/IVが固定・再利用されていないか、トークンが短すぎないか、期限があるか、一回性があるか
  - ログ：Authorization、署名付きURL、Webhook署名、リセットトークン、暗号文/平文の出力
- この例が使えないケース（前提が崩れるケース）：
  - 許可されていないスコープへの検証（倫理・法的問題）
  - 実際の暗号攻撃（目的は観測であり、攻撃ではない）
  - TLSの詳細（`01_topics/01_asm-osint/02_tls_証明書・CT・外部依存推定.md` 側に寄せる）

---

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：暗号、鍵管理
  - 該当要件（可能ならID）：暗号要求、鍵管理
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：暗号を「使っている」だけでは防御にならない。プリミティブ選択（hash/KDF/MAC/sign/encrypt）と境界（何を守るか、何を信じるか、鍵を誰が持つか）がズレると、(1) パスワードが復元可能、(2) トークンが偽造可能、(3) 機微データが復号される、(4) 署名の検証不備で成りすまし、(5) 鍵漏えいが即全損、(6) ログに秘密が流出、が現実に起きる。
    - 満たす：ASVSの暗号要求は「アルゴリズム名」ではなく、(a) 適材適所（hash vs encrypt）、(b) KDF（パスワード/鍵導出）の要件、(c) 署名/検証の正しさ（aud/iss/鍵選択/ローテーション）、(d) 鍵管理（保管・ローテーション・最小権限）、(e) 乱数/nonce/IV/salt の管理、まで含めて境界として設計・実装すること。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：暗号実装の誤用
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：
    - WSTGでは暗号実装の誤用（弱いハッシュ、固定鍵、IV/nonce再利用、署名検証不備、古いTLS/不適切な暗号スイート等）を"観測可能な症状"から追う。API/トークン/クッキー/署名付きURL/Webhook署名など「Webで起きる暗号の接続点」を対象に、入力と境界（どこで検証し、何を信じ、何を残すか）を確定して評価する。
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：Vulnerability Analysis、Exploitation、Reporting
  - 前後フェーズとの繋がり（1行）：
    - 暗号は「破る」より「誤用を突く」領域。PTESでは、(1) 設計レビュー（用途とプリミティブの整合）、(2) 実装レビュー（ライブラリ利用・検証点・鍵管理）、(3) 実証（偽造/再利用/復元可能性が"現実的"か）、の順で結論を固める。報告は"暗号の講義"で終わらせず、境界・影響半径・是正優先度を明確化する。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：Credential Access（T1552）、Defense Evasion（T1562）
  - 攻撃者の目的（この技術が支える意図）：
    - 接続：鍵/トークン/セッションの窃取（Credential Access）、APIキー漏えい、設定ミスによる秘密流出（ログ/設定）、暗号検証の不備によるなりすまし（Defense Evasion ではなく「認証・認可の迂回」）、および侵害後の継続（トークン再利用）に繋がる。
    - 本ファイルは攻撃手順ではなく、攻撃者が「狙う資産（鍵・トークン・署名検証点）」と、防御側が「境界として固める設計」を接続する。
  - 参照：https://attack.mitre.org/tactics/TA0006/（Credential Access）、https://attack.mitre.org/tactics/TA0005/（Defense Evasion）

## 参考（必要最小限）
- OWASP: Cryptographic Storage Cheat Sheet - https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html
- NIST: Cryptographic Standards and Guidelines - https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines
- RFC 7515: JSON Web Signature (JWS) - https://tools.ietf.org/html/rfc7515
- RFC 7516: JSON Web Encryption (JWE) - https://tools.ietf.org/html/rfc7516

## リポジトリ内リンク（最大3つまで）
- 関連 topics：
  - `01_topics/02_web/02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`（セッション/トークン設計の全体）
  - `01_topics/02_web/06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`（Secrets管理の一般）
  - `01_topics/02_web/11_logging_tracing_相関IDと証跡設計.md`（ログ設計）
- 関連 playbooks：
  - （該当するplaybookがあれば記載）
- 関連 labs / cases：
  - `04_labs/02_web/14_crypto_01_password_hashing_kdf_parameters/`（候補）
  - `04_labs/02_web/14_crypto_02_signature_verification_claims_boundary/`（候補）
  - `04_labs/02_web/14_crypto_03_webhook_hmac_timestamp_replay/`（候補）
  - `04_labs/02_web/14_crypto_04_aead_nonce_iv_management_parallel_retry/`（候補）
  - `04_labs/02_web/14_crypto_05_key_rotation_multi_key_acceptance/`（候補）

---

## 深掘りリンク（最大8）
- `01_topics/02_web/02_authn_03_token設計（Bearer_JWT_Refresh_Rotation）.md`
- `01_topics/02_web/02_authn_10_password_reset_回復経路（token_失効_多要素）.md`
- `01_topics/02_web/02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`
- `01_topics/02_web/02_authn_18_token_binding（DPoP_mTLS）観測.md`
- `01_topics/02_web/04_api_04_webhook_受信側の信頼境界（署名_再送）.md`
- `01_topics/02_web/06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）.md`
- `01_topics/02_web/11_logging_tracing_相関IDと証跡設計.md`
- `01_topics/02_web/13_session_replay_再利用と検知（ua_ip_binding）.md`

