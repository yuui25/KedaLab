# 05_input_19_cache_poisoning_03_poisoned_object（stored_response）
Poisoned Object（stored response）：キャッシュに"誤レスポンス"が格納され、境界を跨いで配布される状態を観測・相関で確定する

---

## 目的（この技術で到達する状態）
- 「キャッシュキーが壊れ得る」「unkeyed入力がある」から一歩進み、**格納された誤レスポンス（poisoned object）が"誰に配られるか"** を境界で確定できる。
  1) poisoned object の成立条件（格納・再利用・配布範囲）を分解できる
  2) 観測で"格納されたこと"と"再利用されたこと"を証跡化できる
  3) 影響半径（匿名/ログイン/テナント/地域/UA等）を切り分けられる
  4) 第三者影響を最小化しつつ、侵害評価として成立根拠を作れる
  5) 修正要件を「キャッシュ設計/運用/監視」の観点で提示できる

## 前提（対象・範囲・想定）
- 対象：許可された範囲のWebアプリ/環境のみ。
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - 共有キャッシュ（CDN/Reverse Proxy）が一般的。Poisoned Objectは第三者影響（他者へ配布）を含み得る。
- できること/やらないこと（安全に検証する範囲）：
  - やる：成立根拠の取り方（Store/Serve/Radiusの3条件を証跡で確定）、影響半径の最小化（隔離/短TTL/低頻度）、証跡重視で所見化
  - やらない：第三者影響を出さない設計（隔離環境を優先、実環境では低トラフィックな時間帯、影響が限定されるページ、少数回、可能なら短TTL/パージ可能性の確認）。"広く配って証明"ではなく、store/serve/radiusの証拠を揃える。
- 依存する前提知識（必要最小限）：
  - `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
  - `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：Poisoned Object（格納済みレスポンスの配布）に関する境界モデル・観測・証跡化
    - "格納された"ことの根拠（ヒット/Age/ログ相関/オブジェクトID）
    - "誰に配布されるか"の根拠（共有キャッシュ/キー構成/境界）
    - "何が配布されると危険か"の分類（HTML/JSON/リダイレクト/エラー等）
  - 扱わない（別ユニットへ接続）：
    - keyingの確定 → `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
    - unkeyed入力の特定 → `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - Store（格納）の証拠：ヒット/ミスの遷移（1回目はミス、2回目以降がヒット）、Age等のオブジェクト経過情報（Ageが増加する＝同一オブジェクトが再利用されている兆候）、キャッシュ層ログ（storeイベント、cache key、bypass理由、object id）
  - Serve（再利用）の証拠：同一条件での再現（同じURLで同じオブジェクトが返る）、条件差を付けたときに"同一オブジェクト"が返ってしまう（unkeyed/衝突の根拠）、ETag/Last-Modified が同一のまま配布される（補助証拠）
  - Radius（配布範囲）の証拠：共有キャッシュかどうか（CDN/Reverse Proxyの関与）、キーの構成（Vary/ログ/推定結果）、境界ごとの切り分け（匿名 vs ログイン、テナントA vs B、言語/UA/地域）
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：共有キャッシュ（CDN/Reverse Proxy）か非共有（ブラウザ/個人キャッシュ）か
  - 信頼境界（外部連携・第三者・越境ポイント）：キャッシュに格納されたレスポンス（オブジェクト）が"本来の境界（ユーザ/テナント/機能/表現）"を跨いで再利用されると、アプリ側の認証・認可が正しくても **誤った内容が配布**される
  - 権限境界（権限の切替/伝播/委任）：ユーザ境界（ログイン/個人化）、テナント境界（subdomain/org_id）、機能境界（/admin/設定/エクスポート）、表現境界（言語/圧縮/デバイス）、経路境界（http/https、ホスト、内部ルーティング、パス正規化）
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - Poisoned Object の定義：攻撃者が何らかの入力差（unkeyed、正規化差、層間不一致等）で **"期待しないレスポンス"** を生成させ、そのレスポンスが共有キャッシュ（CDN/Reverse Proxy等）に **格納（store）** され、別の利用者/別条件のリクエストへ **再利用（serve）** される状態
  - 判定の必須3条件：1) Store（キャッシュに格納された証拠）、2) Serve（別のリクエストが"同一オブジェクト"を受け取った証拠）、3) Radius（配布範囲を境界で説明できる）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - Store/Serve/Radiusの3条件が揃っている：キャッシュに格納された証拠、別のリクエストが"同一オブジェクト"を受け取った証拠、配布範囲を境界で説明できる
  - 影響半径（匿名/ログイン/テナント/地域/UA等）を境界で説明できる
- 何が"推定"できるか（推定の根拠/前提）：
  - 実害評価（影響分岐A：配布範囲が匿名・広域、影響分岐B：配布範囲がログイン/特定条件に限定、影響分岐C：配布範囲がテナント跨ぎの可能性）
  - "何が毒になるか"の分類（HTML/JSON/リダイレクト/エラー/静的アセット）
- 何は"言えない"か（不足情報・観測限界）：
  - "第三者へ配布された"断定（実害の断定）は、キャッシュログ/キー/serve証拠がない限り言えない
  - 合成経路（Request Smuggling、CRLF/ヘッダ分割、Open Redirect）は断定せず、「観測された状態」として位置づける（推測で所見化しない）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：Store/Serve/Radiusの3条件が揃っていない → "poisoned"と断定しない
  - パターンB：Store/Serve/Radiusの3条件が揃っている → "poisoned"と断定できる
  - パターンC：影響半径がテナント跨ぎの可能性 → B2Bでは最優先で重大（ただし推測で「テナント跨ぎ」と言わない）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - HTML（ページ）毒：リンク/フォーム/スクリプト参照/メタ情報（OGP等）が含まれる、絶対URL生成が変わる、script/link参照先が変わる、ログイン誘導/遷移誘導が変わる
  - JSON/API 応答毒：フロントが信じるURL/設定/フラグが変わると、後続の挙動（権限操作・遷移）に波及し得る
  - リダイレクト（3xx）毒："どこへ飛ばすか"が毒になる、特にログイン/決済/ダウンロード等の遷移が絡むと影響が大きい
- 優先度の付け方（時間制約がある場合の順序）：
  1) 影響分岐C：配布範囲がテナント跨ぎの可能性 → B2Bでは最優先で重大（必須根拠：Host/Path/Queryの正規化衝突の証拠、共有キャッシュでのキー構成証拠）
  2) 影響分岐A：配布範囲が匿名・広域（共有キャッシュで広く当たる） → 重要度が上がる（影響ユーザ数が大きい）
  3) 影響分岐B：配布範囲がログイン/特定条件に限定 → 重要度は状況依存だが、ユーザ境界破壊なら重大
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：Unkeyed入力で"別レスポンス"を生成 → 同一キーに格納 → そのレスポンスが store され、別条件に serve されるを証跡化する
  - 攻め筋2：正規化差で"別リクエストが同一視" → 衝突して格納 → 衝突が配布範囲（特にテナント境界）に触れるかを評価する
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - キャッシュ層ログが取れない場合：ヒット/ミスの遷移、Age等のオブジェクト経過情報、ETag/Last-Modified で推定する
  - 影響半径が評価できない場合：断定を避け、**観測された状態**として位置づける（推測で所見化しない）

## 次に試すこと（仮説A/Bの分岐と検証）
- 仮説A：Store/Serve/Radiusの3条件が揃っていない（"poisoned"と断定しない）
  - 成立条件：
    - Store（キャッシュに格納された証拠）が取れない、または Serve（別のリクエストが"同一オブジェクト"を受け取った証拠）が取れない、または Radius（配布範囲を境界で説明できる）が取れない
  - 次の検証：
    - 他の観測方法（キャッシュ層ログ、Originログ、ETag/Last-Modified 等）で証拠を取る
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功：Store/Serve/Radiusの3条件が揃う（"poisoned"と断定できる）
    - 失敗：Store/Serve/Radiusの3条件が揃わない（"poisoned"と断定しない）
- 仮説B：Store/Serve/Radiusの3条件が揃っている（"poisoned"と断定できる）
  - 成立条件：
    - Store（キャッシュに格納された証拠）、Serve（別のリクエストが"同一オブジェクト"を受け取った証拠）、Radius（配布範囲を境界で説明できる）が揃っている
  - 次の検証：
    - 影響半径（匿名/ログイン/テナント/地域/UA等）を境界で説明し、実害評価（影響分岐A/B/C）へ接続する
  - 期待する観測：
    - 成功：影響半径が評価できる（実害評価が確定する）
    - 失敗：影響半径が評価できない（ただし"poisoned"成立は確定）
- 仮説C：影響半径がテナント跨ぎの可能性（B2Bでは最優先で重大）
  - 成立条件：
    - Host/Path/Queryの正規化衝突の証拠、共有キャッシュでのキー構成証拠が取れる
  - 次の検証：
    - 必須根拠を揃え、推測で「テナント跨ぎ」と言わない（最も報告品質が問われる）
  - 期待する観測：
    - 成功：テナント跨ぎが確定する（B2Bでは最優先で重大）
    - 失敗：テナント跨ぎが確定しない（ただし"poisoned"成立は確定）

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/02_web/05_input/19_cache_poisoning_03_poisoned_object_stored_response/`（追加候補）
- 取得する証跡（目的ベースで最小限）：
  - Store（格納）の証拠：ヒット/ミスの遷移、Age等のオブジェクト経過情報、キャッシュ層ログ（storeイベント、cache key、bypass理由、object id）
  - Serve（再利用）の証拠：同一条件での再現、条件差を付けたときに"同一オブジェクト"が返ってしまう、ETag/Last-Modified が同一のまま配布される
  - Radius（配布範囲）の証拠：共有キャッシュかどうか、キーの構成、境界ごとの切り分け
- 観測の取り方（どの視点で差分を見るか）：
  - 視点1：Store（格納）の証拠の確定
  - 視点2：Serve（再利用）の証拠の確定
  - 視点3：Radius（配布範囲）の証拠の確定
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/cache_poisoning_poisoned_object 2>/dev/null
    cd ~/keda_evidence/cache_poisoning_poisoned_object
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **証跡重視**（第三者影響を出さない設計）
      - 隔離環境（Lab/ステージング）を優先、実環境では低トラフィックな時間帯、影響が限定されるページ、少数回、可能なら短TTL/パージ可能性の確認
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host、User、Time、キャッシュ層、キー構成、Store/Serve/Radius、影響半径

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# Poisoned Object で最重要なのは「格納された」「再利用された」「誰に配られるか」を証拠で揃えること。
# 広く配って証明しない（第三者影響のリスクが高い）。
# 必要な証跡：
# - hit/miss と時間差（可能なら Age 等）
# - cacheログ（store/serve、key、object id）
# - originログ（受け取った入力と request_id）
~~~~

- この例で観測していること：
  - Store/Serve/Radiusの3条件（キャッシュに格納された証拠、別のリクエストが"同一オブジェクト"を受け取った証拠、配布範囲を境界で説明できる）を証跡で確定する
- 出力のどこを見るか（注目点）：
  - Store（格納）の証拠：ヒット/ミスの遷移、Age等のオブジェクト経過情報、キャッシュ層ログ（storeイベント、cache key、bypass理由、object id）
  - Serve（再利用）の証拠：同一条件での再現、条件差を付けたときに"同一オブジェクト"が返ってしまう、ETag/Last-Modified が同一のまま配布される
  - Radius（配布範囲）の証拠：共有キャッシュかどうか、キーの構成、境界ごとの切り分け
- この例が使えないケース（前提が崩れるケース）：
  - キャッシュ層ログが取れない場合：ヒット/ミスの遷移、Age等のオブジェクト経過情報、ETag/Last-Modified で推定する
  - 影響半径が評価できない場合：断定を避け、**観測された状態**として位置づける（推測で所見化しない）

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：キャッシュ設定、データ保護
  - 該当要件（可能ならID）：動的レスポンスのキャッシュ禁止（no-store/private）を原則とし、例外的にキャッシュする場合は **キー（Keying）と正規化（Normalization）を仕様化**し、レスポンスに影響する入力は必ずキーへ含める（Vary/キー構成の整合）。また、エラー/リダイレクト/ユーザ依存/権限依存/テナント依存のレスポンスを共有キャッシュに載せない。キャッシュ層とオリジンのログ相関（hit/miss・キー・生成元）を整備する。
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：キャッシュに格納されたレスポンス（オブジェクト）が"本来の境界（ユーザ/テナント/機能/表現）"を跨いで再利用されると、アプリ側の認証・認可が正しくても **誤った内容が配布**される。これは情報漏えい、誤誘導、誤配布、監査破綻（真実性の喪失）を引き起こす。
    - 満たす：動的レスポンスのキャッシュ禁止（no-store/private）を原則とし、例外的にキャッシュする場合は **キー（Keying）と正規化（Normalization）を仕様化**し、レスポンスに影響する入力は必ずキーへ含める（Vary/キー構成の整合）。また、エラー/リダイレクト/ユーザ依存/権限依存/テナント依存のレスポンスを共有キャッシュに載せない。キャッシュ層とオリジンのログ相関（hit/miss・キー・生成元）を整備する。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：キャッシュ関連の誤動作
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：Cache Poisoningは「入力→出力」が"保存→再利用"されるため、テストは (1) キャッシュ可能性、(2) キー推定、(3) unkeyed入力の影響、(4) **格納オブジェクトが誰に配られるか（影響半径）** の4段階で評価する。本ファイルは(4)に集中し、成立根拠の取り方を固定する。
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：侵害評価（Impact評価）
  - 前後フェーズとの繋がり（1行）：侵害評価（Impact評価）に直結。Poisoned Objectは第三者影響（他者へ配布）を含み得るため、許可範囲・回数・TTL・対象エンドポイントを厳格に制御し、証跡重視で所見化する。再現性の追求より「境界が崩れた証拠」と「配布範囲の確定」を優先する。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：T1190（Exploit Public-Facing Application）
  - 攻撃者の目的（この技術が支える意図）：T1190（Exploit Public-Facing Application）に接続し得る。Impact（ユーザへの誤配布・劣化）、Collection（混線により情報露出）へ接続し得るが、断定は"配布範囲"と"格納実証"が揃ってから行う。
  - 参照：https://attack.mitre.org/tactics/TA0001/（Initial Access）

## 参考（必要最小限）
- Poisoned Object（poisoned cached response）の定義と解説
- Store/Serve/Radiusの3条件の判定方法
- 影響半径（匿名/ログイン/テナント/地域/UA等）の切り分け方法

## リポジトリ内リンク（最大3つまで）
- 関連 topics：`05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- 関連 topics：`05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- 関連 labs：`04_labs/02_web/05_input/19_cache_poisoning_03_poisoned_object_stored_response/`（追加候補）

---

## 深掘りリンク（最大8）
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_18_http_request_smuggling_04_observable_signals（timing_error_cache）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
- `06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`

---
