# 13_session_replay_再利用と検知（ua_ip_binding）
UA/IP binding を"境界"として成立させる

---

## 目的（この技術で到達する状態）
- 「セッションが盗まれる/再利用される」問題を、**再現可能な境界モデル**として説明できる。
- UA/IP binding を"万能策"として扱わず、以下を切り分けて設計・診断できる：
  - どのトークンが再利用対象か（Cookieセッション / Bearer / 内部トークン / Job文脈）
  - どこで検知するか（Edge/BFF/API/Policy/監査ログ）
  - 何で縛るか（UA/IP/Accept-Language/Device/証明書等）
  - どう反応するか（継続許可/step-up/強制ログアウト/アラート）
  - 誤検知・UX事故をどう抑えるか（NAT/モバイル/プライバシー機能/ローミング）
- "次の一手"をA/B分岐で出せる（検知が弱いのか、失効が弱いのか、バインディングが強すぎるのか）。

## 前提（対象・範囲・想定）
- 対象：セッション再利用（Session Replay/Hijacking）の成立条件と検知
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - Edge/BFF/API/Policy/監査ログ等の検知ポイント
  - NAT/モバイル/プライバシー機能/ローミング等の環境変動
  - 失効・タイムアウト・並行セッション・step-up と組み合わせた"運用可能"な防御
- できること/やらないこと（安全に検証する範囲）：
  - できる：許可されたスコープ内での観測（セッション再利用の検知確認）、UA/IP bindingの確認
  - やらない：実際のセッションハイジャック、許可されていない対象への検証
- 依存する前提知識（必要最小限）：
  - セッション管理の基本、Cookieの基本構造、UA/IP bindingの基本概念
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：
    - セッション再利用（Session Replay/Hijacking）の成立条件と検知
    - UA/IP binding（強制バインディング/ソフトバインディング/リスクスコア）の設計
    - 失効・タイムアウト・並行セッション・step-up と組み合わせた"運用可能"な防御
    - 監査ログ/相関IDを用いた「追跡・封じ込め」の設計
  - 扱わない（別ユニットへ接続）：
    - Cookie属性の詳細 → `02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
    - セッションライフサイクル全体 → `02_authn_02_session_lifecycle（更新_失効_固定化_ローテーション）.md`
    - 端末紐付け全般 → `02_authn_08_device_binding（端末紐付け_IP_UA_fingerprint）.md`
    - Token Binding（DPoP/mTLS等） → `02_authn_18_token_binding（DPoP_mTLS）観測.md`
    - ログ/相関設計 → `11_logging_tracing_相関IDと証跡設計.md`

---


## UA/IP binding の設計：強制バインディングではなく“検知と段階制御”に落とす
### 1) まず決める：バインディングは「阻止」か「検知」か
- 阻止（hard binding）
  - 一致しない場合、即セッション無効化/拒否
  - 強いが、誤検知の損失が大きい（正規ユーザ巻き込み）
- 検知（soft binding）
  - 変更を検出し、(1) step-up、(2) 追加確認、(3) 監査ログ/アラート、(4) 高リスク操作のみ拒否、など段階制御
  - 現実のネットワーク変動・端末変動を吸収しやすい

結論：Web一般では soft binding を基本にし、重要操作だけ hard に寄せる（境界を“操作”で切る）。

### 2) OWASPの観点（何を保存し、どう異常検知に使うか）
- セッション確立時に、IP/UA/Accept-Language/日時などをサーバ側に保存し、著しい変化を検知することでセッションハイジャック検知に繋げる、という整理がある。:contentReference[oaicite:6]{index=6}
- ただし「変化＝攻撃」と直結させると事故が出るため、変化の扱い（許容/段階/例外）を仕様化する。

### 3) 具体の“縛り方”（UA/IPをそのまま一致判定しない）
- IPの扱い（誤検知が起きやすい）
  - NAT（多数ユーザが同一IP）やモバイルローミングでIPは容易に変わる
  - 推奨設計（例）
    - “完全一致”ではなく、短時間の変動を許容する
    - IPv4は/24程度、IPv6は/56〜/64程度のプレフィックス一致など「粗い近似＋監査」に寄せる（環境により調整）
    - 変更時は即拒否ではなく「リスク増加」として扱い、重要操作にだけ効かせる
- User-Agentの扱い（偽装と衝突の両面）
  - UAは同一端末でも更新で変わる。逆に攻撃者が合わせることも可能
  - 推奨設計（例）
    - UA全文一致ではなく、主要要素（ブラウザファミリ/OS/メジャーバージョン）に正規化
    - “同一端末での微差”は許容し、ファミリが変わる（例：Chrome→Safari）など大差を高リスクとする
- Accept-Language 等の補助シグナル
  - 単体では弱いが、UA/IPと組み合わせると“変化の整合性”が取れる
  - 例：IPが変わったがUA/言語/デバイスが同じ → 低〜中リスク、IPもUAも変わった → 高リスク

---

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - セッショントークン：CookieベースのセッションID、Bearerトークン（Access token等）、内部トークン/ヘッダ（Gateway→サービス）、非同期（Job/Queue）
  - UA/IP binding：IP（NAT/ローミング/IPv6プレフィックス変動）、User-Agent（ブラウザ更新、同一UAの衝突、偽装）、Accept-Language 等（環境差で揺れる）、device_id（アプリ発行の端末識別子）、mTLS/DPoP等の暗号学的バインディング
  - セッション状態（サーバ側）：baseline（初回の ip_norm / ua_norm / accept_lang / device_id / created_at）、rolling（直近N回の観測値：変化の履歴が追えると誤検知を減らせる）
  - 監査ログ："疑わしいセッション"として判定した事実（risk_score、理由、対応アクション）を記録し、相関IDで追えるようにする
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：
    - CookieベースのセッションID（典型）：盗まれたセッションIDを提示するだけで、同一ユーザとして振る舞える可能性がある（＝セッションハイジャック）
    - Bearerトークン（Access token等）：トークンがそのまま認証素材として扱われる場合、リプレイ耐性は（署名よりも）“提示者が本人か”の問題になる
    - 内部トークン/ヘッダ（Gateway→サービス）：内部境界が破られると影響半径が大きい（「内部のみ信頼」を崩されると全サービスに波及）
    - 非同期（Job/Queue）："投入時に認証済み"でも、実行時に権限・セッションが有効とは限らない（時間境界）
  - 信頼境界（外部連携・第三者・越境ポイント）：
    - 強い（ただし実装コスト）：mTLS/DPoP等の暗号学的バインディング（提示者を証明）
    - 中程度（設計次第）：device_id（アプリ発行の端末識別子）、セッションに紐付くサーバ側状態（リスク情報）
    - 弱い（誤検知・回避が起きやすい）：IP（NAT/ローミング/IPv6プレフィックス変動）、User-Agent（ブラウザ更新、同一UAの衝突、偽装）、Accept-Language 等（環境差で揺れる）
  - 権限境界（権限の切替/伝播/委任）：
    - 認証済み状態の再利用は、MFAを含む"本人確認ステップ"を既に通過した状態を再現し得るため、重要操作（送金・権限付与・連携追加等）でのstep-up/再認証が重要になる
    - どのイベントで"セッション本人性"を評価しているか：通常リクエスト（GET/画面遷移）で都度チェックしているか、重要操作（権限付与/決済/連携追加/エクスポート）だけでチェックしているか、ログイン直後・トークン更新時・セッション更新時にチェックしているか
    - どのHopで評価しているか：Edge（IPベースの粗い検知はできるが、user_idや操作の意味を理解しにくい）、API/Policy（推奨：user_id/tenant_id/action を含めて"意味のある検知"ができ、監査ログと繋がる）、非同期（Job："実行時"に再評価するのか（権限/セッション有効性）、投入時スナップショットにするのか（要件次第））
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - UA/IP bindingの設計：強制バインディング（hard binding：一致しない場合、即セッション無効化/拒否） vs 検知（soft binding：変更を検出し、(1) step-up、(2) 追加確認、(3) 監査ログ/アラート、(4) 高リスク操作のみ拒否、など段階制御）
  - IPの扱い：完全一致 vs 短時間の変動を許容する、IPv4は/24程度、IPv6は/56〜/64程度のプレフィックス一致など「粗い近似＋監査」に寄せる
  - User-Agentの扱い：UA全文一致 vs 主要要素（ブラウザファミリ/OS/メジャーバージョン）に正規化、"同一端末での微差"は許容し、ファミリが変わる（例：Chrome→Safari）など大差を高リスクとする
  - Accept-Language 等の補助シグナル：単体では弱いが、UA/IPと組み合わせると"変化の整合性"が取れる

---

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - バインディングの有無（再利用は"止める手段がない"か）
  - IP/UAを"厳格一致"で強制しているか（硬すぎて運用事故になりやすいか）
  - soft binding（検知＋段階制御）があり、重要操作でstep-upしているか
  - 検知はあるがログ/相関が弱く、調査ができないか
  - 暗号学的バインディング（DPoP/mTLS等）まで到達しているか
- 何が"推定"できるか（推定の根拠/前提）：
  - セッションIDが取得された場合、提示だけで成立し得る（バインディングなしの場合）
  - 攻撃には強いが、正規ユーザのネットワーク変動でログアウト頻発、サポート負荷増（IP/UAを"厳格一致"で強制している場合）
  - 再利用は一定確率で検知され、被害が重要操作で抑制されやすい（soft binding（検知＋段階制御）があり、重要操作でstep-upしている場合）
  - "盗まれたトークンのリプレイ"が構造的に難しくなる（暗号学的バインディング（DPoP/mTLS等）まで到達している場合）
- 何は"言えない"か（不足情報・観測限界）：
  - 実際のセッションハイジャックの成功の有無（観測だけでは確定できない）
  - 誤検知の実際の発生率（正規ユーザのネットワーク変動の程度）
  - 暗号学的バインディングの実装品質（運用（鍵配布/端末管理）と例外（ブラウザ/SDK混在）の適切性）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：バインディングなし（再利用は"止める手段がない"）
    - 異常：セッションIDが取得された場合、提示だけで成立し得る
  - パターンB：IP/UAを"厳格一致"で強制（硬すぎて運用事故になりやすい）
    - 境界がズレている：攻撃には強いが、正規ユーザのネットワーク変動でログアウト頻発、サポート負荷増
  - パターンC：soft binding（検知＋段階制御）があり、重要操作でstep-up
    - 正常：再利用は一定確率で検知され、被害が重要操作で抑制されやすい
  - パターンD：検知はあるがログ/相関が弱く、調査ができない
    - 境界がズレている：ブロックしても根拠が説明できず、誤検知か攻撃かの切り分けができない
  - パターンE：暗号学的バインディング（DPoP/mTLS等）まで到達
    - 正常："盗まれたトークンのリプレイ"が構造的に難しくなる（実装品質は別途必要）

---

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - セッションクッキー/セッションIDが再利用できると、資格情報なしで認証済みとしてアクセスできる（Web Session Cookieの再利用は公的にも整理されている）
  - CookieベースのセッションID（典型）：盗まれたセッションIDを提示するだけで、同一ユーザとして振る舞える可能性がある（＝セッションハイジャック）
  - Bearerトークン（Access token等）：トークンがそのまま認証素材として扱われる場合、リプレイ耐性は（署名よりも）“提示者が本人か”の問題になる
  - 内部トークン/ヘッダ（Gateway→サービス）：内部境界が破られると影響半径が大きい（「内部のみ信頼」を崩されると全サービスに波及）
- 優先度の付け方（時間制約がある場合の順序）：
  1. バインディングの有無（再利用は"止める手段がない"か）の確認
  2. どのイベントで"セッション本人性"を評価しているか（通常リクエスト/重要操作/ログイン直後・トークン更新時・セッション更新時）の確認
  3. どのHopで評価しているか（Edge/BFF/API/Policy）の確認
  4. 検知はあるがログ/相関が弱く、調査ができないかの確認
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：セッションクッキー/セッションIDの再利用
    - 成立条件：バインディングなし（再利用は"止める手段がない"）
    - 結果：資格情報なしで認証済みとしてアクセスできる
  - 攻め筋2：内部トークン/ヘッダの悪用
    - 成立条件：内部境界が破られる
    - 結果：「内部のみ信頼」を崩されると全サービスに波及
  - 攻め筋3：非同期（Job/Queue）での権限文脈の断絶
    - 成立条件："投入時に認証済み"でも、実行時に権限・セッションが有効とは限らない（時間境界）
    - 結果：時間境界の破綻
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - IP/UAを"厳格一致"で強制している場合：重要操作のみ強制、通常操作はsoftへ。IPは正規化（prefix/AS/地域）して"差分"で扱う
  - soft binding（検知＋段階制御）がある場合："反応"が適切か（即失効か、step-upか、通知か、SOC連携か）を運用要件で詰める
  - 検知はあるがログ/相関が弱い場合：`11_logging_tracing_相関IDと証跡設計.md` の最小セット（trace_id/decision/reason）に合わせて整備

---

## 次に試すこと（仮説A/Bの分岐と検証）
> ここが最重要。条件が違うと次の手が変わる形で書く。

- 仮説A：そもそも再利用検知がない（または見えていない）
  - 成立条件：バインディングなし（再利用は"止める手段がない"）
  - 次の検証：
    1) セッション作成時に baseline（ip/ua/lang/date等）を保存し、変化検知を追加する（soft bindingで開始）
    2) 重要操作に step-up を要求し、認証済みセッションでも追加確認を入れる（MFA/再ログイン）
    3) 監査ログに decision/reason を必須化（「なぜ疑わしいと判断したか」が残らないと運用できない）
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功：soft binding（検知＋段階制御）があり、重要操作でstep-up
    - 失敗：セッションIDが取得された場合、提示だけで成立し得る
- 仮説B：検知はあるが"硬すぎて誤検知"が多い（UX事故）
  - 成立条件：IP/UAを"厳格一致"で強制（硬すぎて運用事故になりやすい）
  - 次の検証：
    1) IP/UAの正規化（全文一致から卒業）と、段階制御（通常操作は許容、重要操作だけ強制）へ移行
    2) "変更が正当なケース"を先に列挙し、救済導線を仕様化（ユーザ通知、再認証、サポートの最小対応）
  - 期待する観測：
    - 成功：重要操作のみ強制、通常操作はsoftへ。IPは正規化（prefix/AS/地域）して"差分"で扱う
    - 失敗：正規ユーザのネットワーク変動でログアウト頻発、サポート負荷増
- 仮説C：検知はあるが"反応"が弱い（気づくだけで止められない）
  - 成立条件：soft binding（検知＋段階制御）があるが、"反応"が弱い
  - 次の検証：
    1) 反応を3段階で固定
       - 低：ログ＋通知（本人に「新しい環境からの利用」）
       - 中：step-up（重要操作ブロック/再認証要求）
       - 高：セッション即失効＋全端末ログアウト（条件は厳格に）
    2) Rate-limit と連携（疑わしいセッションの試行回数を抑制）：`12_rate-limit_設計（API_key_user_ip）.md`
  - 期待する観測：
    - 成功："反応"が適切か（即失効か、step-upか、通知か、SOC連携か）を運用要件で詰める、監査ログの粒度（誰が/どの条件で/何をしたか）を強化する
    - 失敗：再利用は一定確率で検知され、被害が重要操作で抑制されやすいが、"反応"が弱い
- 仮説D：盗用後の失効が効かない（セッション/トークン寿命が長すぎる）
  - 成立条件：セッション/トークン寿命が長すぎる
  - 次の検証：
    1) セッション寿命（idle/absolute）とローテーションを見直し、盗用時の影響時間を短くする
    2) refresh rotation / reuse検知（別ファイル側）と整合させる：`02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`
  - 期待する観測：
    - 成功：盗用時の影響時間が短くなる
    - 失敗：セッション/トークン寿命が長すぎる

---

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/02_web/13_session_replay_01_soft_binding_risk_scoring/`（候補）
    - `04_labs/02_web/13_session_replay_02_step_up_on_sensitive_actions/`（候補）
    - `04_labs/02_web/13_session_replay_03_audit_logs_for_suspicious_session/`（候補）
- 取得する証跡（目的ベースで最小限）：
  - セッション状態（サーバ側）：baseline（初回の ip_norm / ua_norm / accept_lang / device_id / created_at）、rolling（直近N回の観測値：変化の履歴が追えると誤検知を減らせる）
  - 監査ログ："疑わしいセッション"として判定した事実（risk_score、理由、対応アクション）を記録し、相関IDで追えるようにする
  - どのイベントで"セッション本人性"を評価しているか：通常リクエスト（GET/画面遷移）で都度チェックしているか、重要操作（権限付与/決済/連携追加/エクスポート）だけでチェックしているか、ログイン直後・トークン更新時・セッション更新時にチェックしているか
- 観測の取り方（どの視点で差分を見るか）：
  - どのHopで評価しているか：Edge（IPベースの粗い検知はできるが、user_idや操作の意味を理解しにくい）、API/Policy（推奨：user_id/tenant_id/action を含めて"意味のある検知"ができ、監査ログと繋がる）、非同期（Job："実行時"に再評価するのか（権限/セッション有効性）、投入時スナップショットにするのか（要件次第））
  - UA/IP bindingの設計：強制バインディング（hard binding：一致しない場合、即セッション無効化/拒否） vs 検知（soft binding：変更を検出し、(1) step-up、(2) 追加確認、(3) 監査ログ/アラート、(4) 高リスク操作のみ拒否、など段階制御）
  - IPの扱い：完全一致 vs 短時間の変動を許容する、IPv4は/24程度、IPv6は/56〜/64程度のプレフィックス一致など「粗い近似＋監査」に寄せる
  - User-Agentの扱い：UA全文一致 vs 主要要素（ブラウザファミリ/OS/メジャーバージョン）に正規化、"同一端末での微差"は許容し、ファミリが変わる（例：Chrome→Safari）など大差を高リスクとする
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/session_replay 2>/dev/null
    cd ~/keda_evidence/session_replay
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **代表点の抽出** のみ（全セッションを網羅しない）
      - 実際のセッションハイジャックは **行わない**（目的は観測であり、攻撃ではない）
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host（対象ドメイン）
    - Path（対象パス）
    - Time（観測時刻）
    - Session-ID（セッション識別子）
    - User-ID（ユーザ識別子）
    - Tenant-ID（組織識別子）
    - IP-Prefix（IPプレフィックス）
    - UA-Family（User-Agentファミリ）
    - Accept-Language（言語設定）
    - Device-ID（端末識別子）
    - Risk-Score（リスクスコア）
    - Response-Policy（対応ポリシー：allow/step_up/required_reauth/revoke）
    - Request-ID（相関キー）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 目的：
# - UA/IP "一致判定"ではなく、正規化＋差分検知＋段階制御に落とす
# - 判定結果（risk/decision/reason）を監査ログに残し、相関IDで追えるようにする

# サーバ側で持つイメージ（擬似データ）
# session_id:
#   user_id: ...
#   tenant_id: ...
#   baseline:
#     ip_prefix: ...
#     ua_family: ...
#     accept_language: ...
#     created_at: ...
#   last_seen:
#     ip_prefix: ...
#     ua_family: ...
#     seen_at: ...
#   risk_state: low|medium|high
#   response_policy: allow|step_up|required_reauth|revoke
~~~~

- この例で観測していること：
  - UA/IP "一致判定"ではなく、正規化＋差分検知＋段階制御に落とす
  - 判定結果（risk/decision/reason）を監査ログに残し、相関IDで追えるようにする
- 出力のどこを見るか（注目点）：
  - セッション状態（サーバ側）：baseline（初回の ip_norm / ua_norm / accept_lang / device_id / created_at）、rolling（直近N回の観測値）
  - 監査ログ："疑わしいセッション"として判定した事実（risk_score、理由、対応アクション）を記録し、相関IDで追えるようにする
  - どのイベントで"セッション本人性"を評価しているか：通常リクエスト/重要操作/ログイン直後・トークン更新時・セッション更新時
  - どのHopで評価しているか：Edge/BFF/API/Policy
- この例が使えないケース（前提が崩れるケース）：
  - 許可されていないスコープへの検証（倫理・法的問題）
  - 実際のセッションハイジャック（目的は観測であり、攻撃ではない）
  - 暗号学的バインディング（DPoP/mTLS等）の実装品質（運用（鍵配布/端末管理）と例外（ブラウザ/SDK混在）の適切性）

---

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：セッション管理、セッションバインディング
  - 該当要件（可能ならID）：セッション管理（V3）、セッションバインディング要求（V3.2）
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：セッションID（Cookie等）やセッショントークンが第三者に取得されると、同じトークンを提示するだけで"認証済み状態"が再利用され得る（＝Session Hijacking/Replay）。このとき「失効」「再認証」「バインディング（IP/UA等）」「監査ログ」の設計が弱いと、MFAを含めて迂回される可能性がある。
    - 満たす：ASVSのセッション管理（V3）では、(1) セッション生成/更新/失効、(2) Cookie属性、(3) セッションバインディング、(4) ログアウト/タイムアウト、(5) トークンベースの管理などを一貫設計する。特に"セッションバインディング要求（V3.2）"を、誤検知と実運用の折り合い込みで実装する。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：セッション管理テスト（Session Management Testing）
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：
    - WSTGのセッション管理テスト（Session Management Testing）には、セッションハイジャック、並行セッション、ログアウト、タイムアウト等の観点が含まれ、セッション再利用の成立条件（どの属性で縛る/縛らない、どこで検知する）を"観測で確定"するのが主眼。
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：Exploitation、Reporting
  - 前後フェーズとの繋がり（1行）：
    - Exploitationで"再利用できる状態"が見えると、侵害後の継続（再訪問）や横展開（同一セッション文脈での高権限操作）に直結する。Reportingでは、攻撃可能性の指摘に止めず「検知・封じ込め・誤検知抑制」まで落とす（ログ相関、段階制御、失効戦略、例外設計）。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：Credential Access（T1550）、Lateral Movement（T1021）
  - 攻撃者の目的（この技術が支える意図）：
    - セッションクッキーの窃取・再利用は、認証済みの状態を資格情報なしで再現できる行為として整理されている（Web Session Cookie関連）。これにより一部のMFAが迂回され得るため、セッション再利用の検知・失効が重要になる。
  - 参照：https://attack.mitre.org/tactics/TA0006/（Credential Access）、https://attack.mitre.org/tactics/TA0008/（Lateral Movement）

## 参考（必要最小限）
- OWASP: Session Management Cheat Sheet - https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html
- OWASP: Session Management Testing - https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/06-Session_Management_Testing/README
- RFC 6265: HTTP State Management Mechanism - https://tools.ietf.org/html/rfc6265

## リポジトリ内リンク（最大3つまで）
- 関連 topics：
  - `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`（Cookie属性の詳細）
  - `01_topics/02_web/02_authn_02_session_lifecycle（更新_失効_固定化_ローテーション）.md`（セッションライフサイクル全体）
  - `01_topics/02_web/11_logging_tracing_相関IDと証跡設計.md`（ログ/相関設計）
- 関連 playbooks：
  - （該当するplaybookがあれば記載）
- 関連 labs / cases：
  - `04_labs/02_web/13_session_replay_01_soft_binding_risk_scoring/`（候補）
  - `04_labs/02_web/13_session_replay_02_step_up_on_sensitive_actions/`（候補）
  - `04_labs/02_web/13_session_replay_03_audit_logs_for_suspicious_session/`（候補）

---

## 深掘りリンク（最大8）
- `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
- `01_topics/02_web/02_authn_02_session_lifecycle（更新_失効_固定化_ローテーション）.md`
- `01_topics/02_web/02_authn_08_device_binding（端末紐付け_IP_UA_fingerprint）.md`
- `01_topics/02_web/02_authn_16_step-up_再認証境界（重要操作_再確認）.md`
- `01_topics/02_web/02_authn_17_refresh_token_rotation_盗用検知（reuse）.md`
- `01_topics/02_web/02_authn_18_token_binding（DPoP_mTLS）観測.md`
- `01_topics/02_web/11_logging_tracing_相関IDと証跡設計.md`
- `01_topics/02_web/12_rate-limit_設計（API_key_user_ip）.md`

