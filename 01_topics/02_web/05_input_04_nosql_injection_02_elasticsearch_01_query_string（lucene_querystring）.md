# 05_input_04_nosql_injection_02_elasticsearch_01_query_string（lucene_querystring）

## 危険性を一言で
- query_stringがLucene構文として解釈され、検索条件が改変される。

## 最小限の成立判断（目安）
- AND/ORなどの構文差分で件数が変わり、再現できる。

## 観測例（差分のイメージ）
- 期待: 1件、差分: 条件が緩み複数件になる。

## 対策の優先順位
1) query_stringを避けDSLに移行
2) フィールドのallowlist化
3) 構文エスケープ

## 目的（この技術で到達する状態）
- Elasticsearch を利用するWeb/APIで、入力が「文字列」ではなく **Lucene Query String（検索DSLの一種）** として解釈されることで起きる境界破壊を、次の形で評価・説明できる。
  1) 入力点が “検索語” か “検索式（コード）” かを切り分ける  
  2) query_string を採用している場合の **成立根拠（oracle）** を、低侵襲に差分観測で確定する  
  3) 影響を「検索範囲拡大」「認可フィルタ迂回（越境混入）」「DoS（複雑度）」に分解して評価する  
  4) 修正を「エスケープ」ではなく、**query_string回避（simple_query_string / match系）** と **フィールドallowlist + 認可フィルタの別レイヤ適用** に落とす

## 前提（対象・範囲・想定）
- 対象：検索窓（サイト内検索）、一覧フィルタ、監査ログ検索、管理画面検索、サポート用検索、レポート/エクスポートの絞り込み、ESの利用形態：直叩き、アプリ経由、Kibana連携、検索SaaS風の構成
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - 想定実装："検索語をそのまま query_string に入れる" 実装（最も危険）、"高度な検索"としてフィールド指定・演算子を許可する実装（仕様として成立し得るが、設計制約が必須）
  - 本ファイルの焦点：query_string（Lucene Query String）の **構文が入力から成立する** こと自体を、入力→実行境界として扱う
  - 非スコープ（別ファイル）：DSL（bool/filter/script 等）、painless、テンプレ（mustache stored template）は別ファイルで扱う
- できること/やらないこと（安全に検証する範囲）：
  - できること：入力点が "検索語" か "検索式（コード）" かを切り分ける、query_string を採用している場合の **成立根拠（oracle）** を、低侵襲に差分観測で確定する、影響を「検索範囲拡大」「認可フィルタ迂回（越境混入）」「DoS（複雑度）」に分解して評価する、修正を「エスケープ」ではなく、**query_string回避（simple_query_string / match系）** と **フィールドallowlist + 認可フィルタの別レイヤ適用** に落とす
  - やらないこと：高負荷を発生させる検証（DoS相当）や大量抽出は避け、設計上の制約欠如として評価する
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
  - `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - 検索窓（サイト内検索）、一覧フィルタ、監査ログ検索、管理画面検索、サポート用検索、レポート/エクスポートの絞り込み、ESの利用形態：直叩き、アプリ経由、Kibana連携、検索SaaS風の構成、query_string は、ユーザ入力を"そのまま"解析して検索式として解釈する（演算子、フィールド指定、グルーピング等）
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：
    - 入口（input surface）を確定する：どこがES検索へ流れるか、典型入口（優先度高）：`q=` / `query=` / `keyword=`（単純検索）、`filter=` / `where=`（高度検索、JSON文字列のこともある）、管理画面の"詳細検索"（フィールド指定ができるUI）、エクスポート/レポートの絞り込み条件（second-order：保存→後で実行）、判断（次の一手）：入力点を列挙したら「同じ検索でもモードがあるか（basic/advanced）」を確認し、危険な実装分岐（advancedだけquery_string）を疑う
  - 信頼境界（外部連携・第三者・越境ポイント）：
    - sink（検索生成点）を分類する：query_string か、それ以外か、同じESでも、採用するクエリ種類でリスクが変わる、query_string：構文が強力（危険度高）、simple_query_string：危険構文が抑制される（それでも設計制約は必要）、match/multi_match：解析はするが"構文"としての自由度は低い（安全側）、黒箱での推定指標（過度に推測しない）：パースエラー/解析エラーの出方、入力の記号で挙動が揺れるか、"検索語"のつもりの入力で、結果の広がり方が不自然に変わるか、判断：断定はしないが、差分が安定して出る場合は「query_string相当の構文解釈がある」仮説を立てる
  - 権限境界（権限の切替/伝播/委任）：
    - oracle（差分指標）を固定する：エラーより結果差分、Boolean oracle（主証拠）：件数、レスポンス長、ページ数、表示要素、特定カテゴリの出現有無、Error oracle（補助）：query parse error / invalid syntax 等が返る場合は、内部実装（query_string採用）の補助証拠、ただし "エラーの出方" 自体が情報漏えい（例外モデル）なので、主証拠はBooleanに寄せる、Time oracle（補助、DoS配慮）：複雑な構文で遅延が出ることはあるが、性能試験に近づく、→ "長い遅延での検証"は避け、設計上の制約欠如として評価する方向を優先
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - 概念整理：query_string は「検索語」ではなく「検索式」を受ける、query_string は、ユーザ入力を"そのまま"解析して検索式として解釈する（演算子、フィールド指定、グルーピング等）、つまり境界はこうなる、安全側：入力＝検索語（単なる文字列）として扱い、サーバ側で構造を生成する、危険側：入力＝検索式（コード）として扱い、ユーザに"構文"を渡している、実務の結論：「自由入力の検索窓」×「query_string採用」は、境界破壊とDoSの温床になりやすい、→ 原則は **simple_query_string** か **match/multi_match** へ寄せる

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - 入力が「文字列」ではなく **Lucene Query String（検索DSLの一種）** として解釈されることで起きる境界破壊、入力点が "検索語" か "検索式（コード）" かを切り分ける、query_string を採用している場合の **成立根拠（oracle）** を、低侵襲に差分観測で確定する
- 何が"推定"できるか（推定の根拠/前提）：
  - まず Boolean oracle（件数/長さ）で確定する（推奨）
  - エラーが見えるなら、query parse error / invalid syntax 等が返る場合は、内部実装（query_string採用）の補助証拠（ただし "エラーの出方" 自体が情報漏えい（例外モデル）なので、主証拠はBooleanに寄せる）
  - 時間差分は最後（短時間・少回数で、他指標と組み合わせる）
- 何は"言えない"か（不足情報・観測限界）：
  - "検索範囲が確実に拡大した"の断定（仕様として高度検索が存在する可能性）、"DoSが可能"の断定（性能試験は別枠、契約と安全配慮が必要）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：検索範囲の拡大（仕様外の式が通る） → 「検索語」だけ許す想定なのに、演算子やフィールド指定が通るなら境界破壊
  - パターンB：認可フィルタ（tenant/org/owner）の適用漏れ・合成誤り（越境混入） → tenant条件を query_string 内に混ぜている（同レイヤ合成）、フィルタ（bool.filter）のはずが、query側（should/must）と混ざる
  - パターンC：DoS（クエリ複雑度・ワイルドカード・曖昧検索等） → query_string は表現力が高いぶん、計算量が増えやすい

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - 検索窓（サイト内検索）、一覧フィルタ、監査ログ検索、管理画面検索、サポート用検索、レポート/エクスポートの絞り込み
- 優先度の付け方（時間制約がある場合の順序）：
  - まず "検索語"として想定されない記号・構文で、結果（件数/長さ）が安定して変化する、または解析エラー差分が出るかを確認
  - basic/advanced の分岐や別エンドポイントで挙動が揺れるかを確認し、実装分岐を原因として切り出す
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：query_string 相当の構文解釈がある（境界破壊） → 特定記号や構文で結果が不自然に揺れる / 解析エラー差分が出る
  - 攻め筋2：フィールド指定の自由度が過剰（allowlist不在） → UI/パラメータで"どの項目を検索するか"が自由すぎる、または不正なフィールドでも挙動が一貫しない
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - "検索"は機能として存在しやすいので、攻撃より先に **仕様と受理範囲（allowlist）** を確定する（仕様外の構文が通るなら境界破壊）

## 次に試すこと（仮説A/Bの分岐と検証）
> ここが最重要。条件が違うと次の手が変わる形で書く。

- 仮説A：（query_string 相当の構文解釈がある（境界破壊））
  - 次の検証："検索語"として想定されない記号・構文で、結果（件数/長さ）が安定して変化する、または解析エラー差分が出る
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功：差分指標（件数/長さ/ページ数）を固定し、同入力点で再現性を取る、basic/advanced の分岐や別エンドポイントで挙動が揺れるかを確認し、実装分岐を原因として切り出す
    - 失敗：特定記号や構文で結果が不自然に揺れる / 解析エラー差分が出る、query_string を避け、simple_query_string または match/multi_match へ移行、どうしても必要なら、受理するフィールドと構文を大幅に制限（ただし"安全運用"は難度が高い）
- 仮説B：（フィールド指定の自由度が過剰（allowlist不在））
  - 次の検証：UI/パラメータで"どの項目を検索するか"が自由すぎる、または不正なフィールドでも挙動が一貫しない
  - 期待する観測：
    - 成功：受理されるフィールド集合を観測で推定し（不正値が通る/落ちるの混在）、allowlist欠落として原因固定、返却フィールド（source）も含めて縮退の必要性を報告に入れる
    - 失敗：ユーザが任意フィールドに触れられる設計（高度検索UIやパラメータ）、サーバ側マッピング（UIの選択肢→内部フィールド）を導入し、入力をフィールド名にしない、返却も source filtering（返してよいフィールドのみ）で縮退
- 仮説C：（認可フィルタの適用が揺れている（越境混入リスク））
  - 次の検証：テナント/ロール/ユーザの切替で、本来変わらないはずの検索面積が不自然に変わる
  - 期待する観測：
    - 成功："固定条件がどこで適用されているか（queryかfilterか）" を設計課題として切り出し、共通部品化を修正方針にする
    - 失敗：tenant条件が入力と同レイヤで混ざっている（上書き・揺らぎ）、認可条件は bool.filter 等のフィルタレイヤで強制し、ユーザ入力は query 部分に限定する、"固定条件"はアプリの共通部品で一元適用（実装分岐をなくす）

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - 参照ファイル：`04_labs/02_web/05_input/04_nosql_injection_elasticsearch_query_string/`
- 取得する証跡（目的ベースで最小限）：
  - HAR：baseline / 差分（件数） / 差分（エラー）、サーバログ：trace_id、選択された検索方式（query_string等）、クエリ長、実行時間、ヒット数、ES側（Labsのみ）：slowlog、有効なクエリ種別、タイムアウト発生状況
- 観測の取り方（どの視点で差分を見るか）：
  - 目的：同一検索UIで「query_string採用」「simple_query_string」「match系」を差し替え、境界差分（構文解釈・DoS・認可適用）を比較できるようにする、最小構成（推奨）：(1) 安全：match/multi_match + 認可filter強制 + フィールドallowlist、(2) 危険：自由入力を query_string へ直結、(3) 中間：simple_query_string（構文を抑制）+ 認可filter強制、(4) 認可誤り例：tenant条件を query 側に混ぜる（悪い例として比較）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 危険：自由入力を query_string に直結（入力が"検索式"になる）

{ "query": { "query_string": { "query": userInput } } }

# 安全：キーワードは match 系で扱い、構文はユーザに渡さない

{ "query": { "multi_match": { "query": userInput, "fields": allowedFields } } }
~~~~

- この例で観測していること：query_stringの使用、match系への移行、構文の抑制
- 出力のどこを見るか（注目点）：検索結果の件数、エラーの有無、クエリの生成方法
- この例が使えないケース（前提が崩れるケース）：仕様として高度検索が必要な場合、または完全に静的なクエリのみを使用している場合

~~~~
# 危険：認可条件をユーザ入力と同レイヤで合成（揺らぎやすい）

# （固定条件が"検索式"と混ざる設計は避ける）

# 安全：認可は filter レイヤで強制、入力は query へ閉じ込める

{ "query": { "bool": { "filter": [ tenantFilter ], "must": [ userQuery ] } } }
~~~~

- この例で観測していること：認可条件の適用レイヤ、filterとqueryの分離
- 出力のどこを見るか（注目点）：検索結果の件数、認可条件の適用範囲、固定条件の揺らぎ
- この例が使えないケース（前提が崩れるケース）：認可条件が固定されていない場合、または完全に静的なクエリのみを使用している場合

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V5 Validation, Sanitization and Encoding、V7 Error Handling and Logging
  - 該当要件（可能ならID）：V5.3.1、V5.3.2、V7.4.1
  - このファイルの内容が「満たす/破れる」ポイント：
    - 入力→実行境界：ユーザ入力が「検索語」ではなく **Luceneクエリ構文（演算子・フィールド指定・グルーピング）** として解釈される境界を閉じているか
    - 認可境界：tenant/org/owner 条件（フィルタ）を検索式と **同じ層で合成** していないか（検索式が優先・上書き・拡張される設計は危険）
    - 例外/エラー：パースエラー、解析エラー（analysis）、正規化差分を外部へ漏らさない（oracle化防止）
    - DoS境界：クエリ複雑度（ネスト/ワイルドカード/曖昧検索等）を制限し、タイムアウト・結果上限・rate limit を設計で担保できているか
    - 監査：query_string の使用、異常な構文（演算子頻出・広範囲検索・高コスト）をログ相関で検知できるか
- WSTG：
  - 該当カテゴリ/テスト観点：WSTG-INPV-05 SQL Injection、WSTG-ERRH-01 Error Handling
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：
    - Injection（入力→実行）として、SQLiと同じ流れで「入口→sink（ESクエリ生成点）→差分観測→成立根拠」を取る
    - "検索"は機能として存在しやすいので、攻撃より先に **仕様と受理範囲（allowlist）** を確定する（仕様外の構文が通るなら境界破壊）
- PTES：
  - 該当フェーズ：Vulnerability Analysis、Exploitation、Reporting
  - 前後フェーズとの繋がり（1行）：検索API/一覧/ログ閲覧/管理UIを中心に、ESのクエリ生成方式（query_string / simple_query_string / match / DSL）を特定し、影響実証は必要最小限（越境混入・検索範囲拡大の成立を示す）。高負荷試験は避ける、根本原因を「query_string採用」「フィールドallowlist不在」「認可フィルタ合成の誤り」「複雑度制限不在」に分解して提示
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：TA0001 Initial Access（公開アプリ入口）/ TA0009 Collection（検索で横断収集）/ TA0005 Defense Evasion（エラー統一下でブラインド化）
  - 攻撃者の目的（この技術が支える意図）：T1190 Exploit Public-Facing Application（検索入力の実行境界破壊）

## 参考（必要最小限）
- Elasticsearch Documentation: https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html
- Elasticsearch Query String Query: https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html
- OWASP Injection Prevention Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Injection_Prevention_Cheat_Sheet.html

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 深掘りリンク（最大8）
- `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
- `01_topics/02_web/05_input_04_nosql_injection_02_elasticsearch_02_dsl（bool_filter_script）.md`
- `01_topics/02_web/05_input_04_nosql_injection_02_elasticsearch_03_painless（script_injection）.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
