# 05_input_06_xss_02_格納_境界モデル

## 目的（この技術で到達する状態）
- 格納XSSを「保存された入力が後で表示される」以上に、**境界モデル**として説明できるようにする
  - どこに保存されたか（格納点：DB/検索/ログ/キャッシュ/ファイル）
  - どこで再表示されるか（再表示点：UI/API/export/通知/管理画面）
  - 誰が被害者か（閲覧者の権限：一般/運用/管理/他テナント）
  - どの“実行コンテキスト”に入ったか（HTML/属性/JS/URL/CSS）
  - どの防御（テンプレ自動エスケープ、サニタイズ、CSP）が、どの境界を守れていないか :contentReference[oaicite:2]{index=2}
- 「攻撃より」の意思決定として、次を即断できる
  - 影響が最大になる被害者（管理/運用）へ到達する“閲覧導線”があるか（通知・一覧・監査ログ・モデレーション等）
  - 反射よりも深刻になりやすい理由（誘導不要、持続、複数被害者、再発経路の多さ）を報告に落とせる

## 前提（対象・範囲・想定）
- 対象：ユーザ生成コンテンツ（UGC）：コメント、プロフィール、チケット本文、記事、レビュー、チャット、テンプレ、メモ、タグ、商品説明、"UGCに見えない"が実務で多い：監査ログ表示、管理コメント、エラー/検証結果表示、インポート結果、CSV/PDF出力プレビュー
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - WAF/簡易フィルタあり（ただし本質対策にならない前提）、リッチテキスト/Markdown/テンプレ等の「部分的にHTMLを許す」要件（ここが最頻の混入点）、CSPが一部導入されている場合（nonce/strict CSP の有無で"実行の成立条件"が変わる）
  - 本ファイルの範囲：**格納（永続化）→再表示→実行**のモデル化と、現実の格納点/再表示点の洗い出し、DOM XSS の詳細（クライアント側sink/source、フレームワーク特有）は次ファイル（03_DOM）で扱う
- できること/やらないこと（安全に検証する範囲）：
  - できること：どこに保存されたか（格納点：DB/検索/ログ/キャッシュ/ファイル）、どこで再表示されるか（再表示点：UI/API/export/通知/管理画面）、誰が被害者か（閲覧者の権限：一般/運用/管理/他テナント）、どの"実行コンテキスト"に入ったか（HTML/属性/JS/URL/CSS）、どの防御（テンプレ自動エスケープ、サニタイズ、CSP）が、どの境界を守れていないか、影響が最大になる被害者（管理/運用）へ到達する"閲覧導線"があるか（通知・一覧・監査ログ・モデレーション等）、反射よりも深刻になりやすい理由（誘導不要、持続、複数被害者、再発経路の多さ）を報告に落とせる
  - やらないこと：目的は成立根拠の確定と影響評価。PoCは「最小の実行確認」まで（情報窃取・持続化・外部送信の具体化には踏み込まない）
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/05_input_06_xss_01_反射_境界モデル.md`
  - HTML/JS/URLの基本コンテキスト、出力エンコーディング（コンテキスト依存）、CSPの基本（script-src、nonce/strict CSP）
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

## 境界モデル（入力→保存→再表示→実行）
### 1) 格納点（Persistence Boundary）
- DB：本文/タイトル/表示名/署名/テンプレ/注釈/メタ情報
- 検索/分析：Elasticsearch等のindex（“表示用に整形した値”が別途格納されることがある）
- キャッシュ：レンダリング済みHTMLのキャッシュ（CDN/アプリ内）
- ログ：監査ログ、操作ログ、Webhookログ、APIログ（運用UIで閲覧される）
- ファイル/オブジェクト：HTML断片、エクスポート生成物、テンプレ資産

### 2) 再表示点（Render Boundary）
- 一般ユーザ画面：詳細/一覧/通知/タイムライン
- 管理/運用画面：モデレーション、検索、監査、問い合わせ対応、ジョブ結果一覧（最優先で危険）
- API：JSONに入るだけに見えて、フロントが `innerHTML` 等で描画しDOM XSSへ合流することがある（“格納→API→DOM”）
- export：CSV/PDF/HTMLレポート（閲覧者が運用者になりやすい）
- 通知：メール/Slack/Teams等（HTMLメール、プレビューUI、リンク展開で別レンダラが動く場合）

### 3) 実行コンテキスト（Execution Context）
- HTML本文 / 属性値 / URL属性 / JS文字列 / JSON埋め込み / CSS
- 格納XSSは「同じデータが複数画面で別コンテキストに入る」事故が多い
  - 例：詳細画面は安全だが、一覧画面の “短縮表示” が unsafe など（= “再表示点差分”が本体）

---

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - どこに保存されたか（格納点：DB/検索/ログ/キャッシュ/ファイル）、どこで再表示されるか（再表示点：UI/API/export/通知/管理画面）、誰が被害者か（閲覧者の権限：一般/運用/管理/他テナント）、どの"実行コンテキスト"に入ったか（HTML/属性/JS/URL/CSS）、どの防御（テンプレ自動エスケープ、サニタイズ、CSP）が、どの境界を守れていないか
- 何が"推定"できるか（推定の根拠/前提）：
  - まず Boolean oracle（DOM構造の変化、属性境界の変化、JS構文エラー/挙動差分）で確定する（推奨）
  - エラー差分は補助（JS構文エラー/挙動差分が入力に連動する兆候）
  - CSP状態を記録（CSPは"成立可否"を左右する）
- 何は"言えない"か（不足情報・観測限界）：
  - 反射がある＝必ず任意JS実行、とは限らない（コンテキスト適切エスケープやCSPで止まる）、本番での実害（情報窃取等）は、権限・操作導線・CSP・SameSite等の複合で決まるため、追加観測が必要
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：入力側サニタイズに依存している（出力側が生） → 一度通った値が、別画面（管理・一覧・メール）で raw 表示されると破綻
  - パターンB：リッチテキスト/Markdown/テンプレ機能が混ざっている → "一部HTMLを許す"設計は、許可リストとレンダラ差分（画面ごとに違うレンダラ）で事故りやすい
  - パターンC：二次利用（再掲・引用・要約）で別コンテキストに落ちる → 「要約」「引用」「カード表示」「OGP」「通知」のように、同じデータが "別テンプレ" に入る

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - ユーザ生成コンテンツ（UGC）：コメント、プロフィール、チケット本文、記事、レビュー、チャット、テンプレ、メモ、タグ、商品説明、"UGCに見えない"が実務で多い：監査ログ表示、管理コメント、エラー/検証結果表示、インポート結果、CSV/PDF出力プレビュー
- 優先度の付け方（時間制約がある場合の順序）：
  - 被害者（閲覧者）のランク付け：Tier 0：運用/管理（管理コンソール、サポートUI、監査ログビューア）、Tier 1：他ユーザ（同一テナント内の一般ユーザ）、Tier 2：自己（self-XSS：基本は低いが、運用UI/支援ツール経由でTier0に跳ねると危険）
  - "閲覧が必ず発生する"導線：モデレーション（未承認投稿のレビュー）、問い合わせ（サポートが必ず見る）、監査/アラート（セキュリティ/運用が必ず見る）、通知（新規投稿・メンション・エラーの通知）
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：一般画面は安全だが、管理/運用画面で未対策（最頻・最危険） → 管理画面の一覧/検索/詳細/監査表示で同一データの"別レンダリング"を確認（短縮・ハイライト・引用が特に狙い目）
  - 攻め筋2：検索/ハイライト（強調表示）が別実装で事故っている → 検索結果のハイライト箇所が `innerHTML` 等で描画されていないか（DOM編へ接続）
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - 格納XSSは「どこで誰が見るか」が価値。payloadの工夫より、**閲覧導線**の設計ミスを突く、影響の現実評価（実行できた後に何が起こるか）：被害者権限での操作代行（承認、権限変更、設定変更、課金、データ閲覧）、権限伝播（管理画面で見た場合の影響が大きい）

## 成立根拠（差分＝成立根拠）を取る：最大限現実寄り
格納XSSは「保存できた」「別ページで表示された」「その表示が“実行コンテキスト”だった」を分解して証拠化する。

### 1) まずは “格納できた” を証明する（保存点の確定）
- 入力に **ユニークマーカー** を入れる（例：短い英数字＋タイムスタンプ）
- 保存後に以下を確認
  - 再編集画面に同じ値が残っている（DB格納の最短証拠）
  - APIレスポンス/一覧/検索結果に同じ値が含まれる（再表示点候補が増える）

### 2) 次に “再表示点の全探索” をする（同一データが出る場所を潰し切る）
- 探索の順序（現実で当たりやすい）
  1) 一覧（短縮表示・ハイライト・サマリ生成が事故りやすい）
  2) 管理/運用（サニタイズが甘い or “信頼済み”扱いされがち）
  3) 検索（ハイライト表示、クエリ強調、タグ表示）
  4) 通知（HTMLメールテンプレ、プレビュー）
  5) export（HTML/PDF生成のテンプレ）
- 重要：同じ入力でも、表示点ごとに「エスケープ方式」が変わる（= 差分観測の価値）

### 3) 最後に “実行コンテキストに入った” を確定する
- コンテキスト別に、成立根拠を言語化する（payload依存にしない）
  - HTML本文：DOM構造が変わる／要素として解釈される兆候
  - 属性：属性境界（クォート）や値の構造が変わる兆候
  - JS/JSON：構文エラー/挙動差分が入力に連動する兆候
- 併せてCSP状態を記録（CSPは“成立可否”を左右する） :contentReference[oaicite:4]{index=4}

---

## “格納XSSあるある”の深掘り（設計ミスのパターン）
### パターン1：入力側サニタイズに依存している（出力側が生）
- 一度通った値が、別画面（管理・一覧・メール）で raw 表示されると破綻
- 重要：XSS対策は原則「出力時（コンテキスト別）」が主。入力時フィルタは補助であり、完全性がない :contentReference[oaicite:5]{index=5}

### パターン2：リッチテキスト/Markdown/テンプレ機能が混ざっている
- “一部HTMLを許す”設計は、許可リストとレンダラ差分（画面ごとに違うレンダラ）で事故りやすい
- 典型事故：本文はサニタイズ済みだが、プレビュー/検索ハイライト/引用表示が別実装で未対策

### パターン3：二次利用（再掲・引用・要約）で別コンテキストに落ちる
- 「要約」「引用」「カード表示」「OGP」「通知」のように、同じデータが “別テンプレ” に入る
- ここで属性/JSに入りやすく、反射よりも再現が安定する

### パターン4：テナント/権限境界と合流する（最も危険）
- 他テナントの運用者が閲覧する導線（共有・承認・監査）で発火すると、影響が跳ねる
- したがって格納XSSは **AuthZ（閲覧範囲）** とセットで評価する（どのロールが閲覧できるか）

### パターン5：CSPはあるが “例外” が多い
- `unsafe-inline` や広い許可ドメイン、またはnonce運用が部分的で、ページごとに強度が違う
- nonce/strict-dynamic の考え方を理解し、「このページのCSP強度」を証拠として残す :contentReference[oaicite:6]{index=6}

---

## 確認（最大限詳しく：現場手順としてブレない形）
### 手順0：対象データ（候補）を“格納型”で分類する
- 文字列（短文）／長文（本文）／リッチテキスト／タグ配列／テンプレ（差し込み）／メタ情報（タイトル等）
- それぞれで “再表示点” がどこに出るか仮説を立てる（一覧・検索・通知・管理）

### 手順1：マーカーで格納→再表示の経路を作る
- 入力にユニークマーカーを設定（例：`keda_xss_store_YYYYMMDDhhmm`）
- 保存・編集・一覧・検索・管理画面で、そのマーカーがどこに出るかを列挙する
- ポイント：ここでは実行させない。経路と文脈の棚卸しが目的

### 手順2：表示点ごとに“コンテキスト”を確定する
- 表示HTMLの該当断片を取り、マーカーが
  - テキストノードか
  - 属性値か（href/src/data-* など）
  - script/JSON内か
  を分類する
- CSPヘッダも同時に控える（ページごとに差がある） :contentReference[oaicite:7]{index=7}

### 手順3：最小PoCで“実行境界を跨いだ”根拠を取る
- 実務の推奨：破壊や外部通信ではなく、UI上の最小変化で成立根拠を取る（監査・再現性・安全性の観点）
- ここで重要なのは payload の技巧ではなく、
  - “どの表示点で”
  - “どのコンテキストで”
  - “どの防御が効いていないか”
  を確定すること

### 手順4：被害者・導線・影響を確定する（攻撃よりの本体）
- 被害者（誰が見るか）を確定：一般/運用/管理
- 閲覧導線を確定：通知、一覧、問い合わせ、監査、モデレーション
- 影響を確定：被害者権限で可能な操作（重要操作があるなら最優先）
- これを「再現手順」と「影響説明」に落とし込む（CTFでなく実務評価）

---

## 次に試すこと（仮説A/B分岐）
- 仮説A：一般画面は安全だが、管理/運用画面で未対策（最頻・最危険）
  - 次：管理画面の一覧/検索/詳細/監査表示で同一データの“別レンダリング”を確認（短縮・ハイライト・引用が特に狙い目）
- 仮説B：検索/ハイライト（強調表示）が別実装で事故っている
  - 次：検索結果のハイライト箇所が `innerHTML` 等で描画されていないか（DOM編へ接続）
- 仮説C：通知/メール/外部連携でレンダラが違う
  - 次：通知テンプレのエスケープ・HTML許可範囲・プレビューUIの実装を確認
- 仮説D：CSPが強いページと弱いページが混在
  - 次：弱いページ（CSP無し/例外多い）での成立根拠を優先的に確定し、CSP統一の改善提案へ

---

## 手を動かす検証（Labs連動：現実に寄せた再現）
- 追加候補Lab：
  - `04_labs/02_web/05_input/06_xss_stored_boundary/`
- 再現要件（現実寄り）
  - UGC保存（DB）
  - 表示点を最低3つ用意（一般詳細／一般一覧（短縮）／管理一覧）
  - 表示点ごとにレンダラ/テンプレを変える（“事故の起き方”を再現）
  - CSPを段階導入（無し→弱い→nonce/strict）で差分を体感
- 証跡
  - HAR（保存→表示点A/B/C）
  - HTML断片（反射位置、コンテキスト）
  - CSPヘッダ（ページごと）

---

## コマンド/リクエスト例（最小限：意味が伝わる“観測用”）
~~~~
# 目的：格納→再表示点の棚卸し（実行させない）
# 1) 投稿/保存リクエストにユニークマーカーを入れる
POST /comment
Body: { "body": "keda_xss_store_20251219_2230" }

# 2) 一覧/詳細/管理で同じマーカーがどこに出るか確認する
GET /comments
GET /comments/123
GET /admin/moderation/comments
~~~~
- この例で観測していること：
  - 格納点（保存された）と、再表示点（どこで見えるか）の網羅
  - 表示点ごとのHTMLコンテキスト差分

---

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V5 Validation, Sanitization and Encoding、V7 Error Handling and Logging
  - 該当要件（可能ならID）：V5.3.1、V5.3.2、V7.4.1
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる点：不正入力がデータストアに永続化され、別ユーザ/別権限の表示コンテキストで"実行"に変わる（入力→保存→表示の信頼境界破壊）。対策は入力フィルタではなく、コンテキスト別出力エンコーディング＋適切なサニタイズ＋テンプレ運用（raw/unsafe例外の統制）＋CSP
- WSTG：
  - 該当カテゴリ/テスト観点：WSTG-INPV-01 Testing for Stored Cross Site Scripting
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：
    - Testing for Stored Cross Site Scripting（格納XSS）に対応（ユーザ入力が保存され、後で取り出されて表示されることが本質）
- PTES：
  - 該当フェーズ：Vulnerability Analysis、Exploitation、Reporting
  - 前後フェーズとの繋がり（1行）：格納点（DB/検索Index/キャッシュ/ログ/オブジェクトストレージ）と再表示点（画面/API/export/通知）を結び、被害者（一般/管理/運用）を定義し、成立根拠（実行コンテキスト確定）＋影響（どの権限で、どの操作が可能か）を最小PoCで示す、原因を「保存時の型/制約不備」「再表示のコンテキスト別エスケープ不備」「サニタイズ誤用」「CSP不備」「権限境界（管理画面/運用UI）での表示」へ分解
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：Initial Access / Execution
  - 攻撃者の目的（この技術が支える意図）：Web閲覧を起点にクライアント側へ影響（Drive-by Compromise: T1189 へ接続）、実務では「被害者権限での操作代行（Account/Workflow乗っ取り）」が中心で、後続は環境依存（SaaS/IdP/管理画面への踏み台になり得る）

## 参考（必要最小限）
- OWASP WSTG：Testing for Stored Cross Site Scripting（格納XSSの定義とテスト観点）
- OWASP Cheat Sheet：XSS Prevention（コンテキスト別エンコーディングの原則）
- MDN：CSP（script-src、nonce/strict-dynamic 等）
- MITRE ATT&CK：Drive-by Compromise（T1189）

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/05_input_06_xss_01_反射_境界モデル.md`
- `01_topics/02_web/05_input_06_xss_03_DOM_境界モデル.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`

---

## 深掘りリンク（最大8）
- `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
- `01_topics/02_web/05_input_06_xss_01_反射_境界モデル.md`
- `01_topics/02_web/05_input_06_xss_03_DOM_境界モデル.md`
- `01_topics/02_web/06_config_03_セキュリティヘッダ（CSP_HSTS_Frame_Referrer）.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
