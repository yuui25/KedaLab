# 05_input_03_sql_injection_02_mysql（境界_プレースホルダ_動的組立）

## 危険性を一言で
- 入力がSQLの「値」ではなく「構文」として解釈されると、条件や実行範囲が変わる。

## 最小限の成立判断（目安）
- A/B比較で件数差分・エラー差分・時間差分のいずれかが安定して再現する。
- エラーは「成立根拠」と「情報露出」を分け、根拠は差分の再現で示す。

## 観測例（差分のイメージ）
- Boolean: 1件→0件（条件が偽になる）
- Time: 応答が +3s 以上遅延する

## 対策の優先順位
1) プレースホルダで値を固定
2) 識別子/構文はallowlistで生成
3) DB権限の最小化と監査

## 目的（この技術で到達する状態）

- MySQL を使うWeb/APIで、SQLiを「入力→SQL実行」越境として**境界モデル化**し、次を“再現性”をもってできる状態になる。
  1) プレースホルダ（Prepared Statement）で守れている範囲／守れていない範囲を切り分ける  
  2) 守れていない典型である **動的SQL組立（ORDER/LIMIT/IN/識別子/断片）** を、黒箱でも差分観測で特定する  
  3) MySQL 方言（Oracle/PostgreSQL/MSSQLとの差分）を「成立根拠」として整理し、誤検知・見落としを減らす  
  4) 修正を「エスケープ強化」ではなく、**設計（組立禁止・allowlist・クエリ生成器）**に落とす

## 前提（対象・範囲・想定）
- 対象：典型（Webフォーム／REST／GraphQL／管理UI／検索・フィルタ・ソート・ページングがある画面）、DB（MySQL / MariaDB（方言・機能差はあるが、まずMySQL基準で整理する））
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - 想定される実装：ドライバ（JDBC、PHP mysqli/PDO、Node mysql/mysql2、Go database/sql、Python MySQLdb 等）、ORM/Query Builder（Sequelize/TypeORM/Prisma/Knex、Hibernate（方言はMySQL）等）
  - スコープ（本ファイルの焦点）：プレースホルダの境界（値のバインドは安全でも、SQL"構文"側に入力が混ざると破綻する）、動的組立（ORDER BY / LIMIT / テーブル名・カラム名 / INリスト / 条件断片（WHERE句の部分）など）、コネクタ設定（複文（multi-statements）やエミュレートドプリペア（client-side prepare）が境界を崩す）
  - パラメータ化（プレースホルダ）を"万能薬"にせず、**動的SQL組立（ORDER/LIMIT/IN/識別子/断片）**の境界を別枠で制御する。DBコネクタ設定（例：multi-statements）を"境界条件"として固定し、攻撃面を縮退させる。例外・エラー差分を「存在オラクル／型オラクル／実装漏えい」にしない（観測点の縮退）。
- できること/やらないこと（安全に検証する範囲）：
  - できること：プレースホルダ（Prepared Statement）で守れている範囲／守れていない範囲を切り分ける、守れていない典型である **動的SQL組立（ORDER/LIMIT/IN/識別子/断片）** を、黒箱でも差分観測で特定する、MySQL 方言（Oracle/PostgreSQL/MSSQLとの差分）を「成立根拠」として整理し、誤検知・見落としを減らす
  - やらないこと：大量データ抽出の手順化、破壊的検証（本リポジトリは「意味→判断→次の一手」優先）、単発の500や単発の遅延だけでは主張しない（ネットワーク、バックエンド混雑、アプリ例外が混ざる）
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/05_input_03_sql_injection_01_oracle（境界_プレースホルダ_ORM）.md`
  - `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
  - `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

## 観測ポイント（何を見ているか：プロトコル/データ/境界）

### 1) まず切るべき境界：値（data）と構文（code）のどちらに入っているか

- 値（data）に入る（本来安全にできる領域）
  - 例：WHERE name = ?、WHERE id = ?、INSERT values (?)、LIKE ?（%を含めて値として渡す）
  - 正攻法：プレースホルダ + 型（数値/文字/日付）で縛る
- 構文（code）に入る（プレースホルダで守れない・守りにくい領域）
  - 例：ORDER BY {user_input}、LIMIT {user_input}、IN ({csv})、WHERE {fragment}、SELECT {columns}
  - 正攻法：**allowlist（選択肢）**＋サーバ側でマッピング（列名や方向を“入力値そのもの”で使わない）

> 重要：SQLi の実務的な半分以上は「値のエスケープ漏れ」ではなく、**構文側の動的組立**か、**ORMのraw断片**で発生する。

### 2) MySQL特有の“差分＝成立根拠”（他方言との比較で見落としを減らす）

#### 2.1 コメント構文（観測で方言を当てる／成立条件の根拠）
- MySQL：
  - `-- `（**後ろにスペース必須**になりやすい実装が多い）
  - `#`（MySQLでよく出る。Oracle/PostgreSQLでは一般的ではない）
  - `/* ... */`（共通だが、方言で許容差がある）
- 差分の意味：
  - 「コメントで後続を無効化できるか」は、**入力が構文に混ざっている**強い証拠になる
  - `#`が効くならMySQL（またはMySQL互換）である可能性が上がる

#### 2.2 識別子のクォート
- MySQL：バッククォート `` `col` `` が頻出
- Oracle/PostgreSQL：主にダブルクォート `"col"`（意味は“大小区別の識別子”）
- 差分の意味：
  - ORDER BY / SELECT列の“列名注入”は、識別子クォートの差分がそのまま成立条件になる
  - 例：バッククォートがエラー文に出る／アプリがバッククォートで組立している → MySQL方言の強い根拠

#### 2.3 文字列エスケープとSQL MODE（成立条件が“設定”で変わる）
- MySQLは `\` エスケープや SQL MODE（例：ANSI_QUOTES / NO_BACKSLASH_ESCAPES 等）で挙動が変わりやすい
- 差分の意味：
  - 「同じ入力でも環境で成立/不成立が揺れる」＝**実装依存の境界**（再現性の担保が必要）
  - WAFやミドルで正規化が入ると、さらに差分が増える（“観測点”が増える）

#### 2.4 連結（concat）の方言差
- Oracle：`||` が文字列連結の主役
- MySQL：一般には `CONCAT(a,b)` が主役（`||` はSQL MODE等で意味が変わることがある）
- 差分の意味：
  - 連結を前提とした検証は、**Oracle向けの当て込みがMySQLで外れる**（誤検知や手戻りの原因）

#### 2.5 複文（stacked queries）成立の“境界条件”
- MSSQL：バッチ境界（; や GO 等）で複文が成立しやすい文化がある
- MySQL：複文は**ドライバ設定**に依存（例：Nodeの `multipleStatements`、PHP PDOの属性、JDBCのallowMultiQueries等）
- 差分の意味：
  - 「複文が通る/通らない」は MySQLi の影響度を大きく変えるが、**脆弱性の有無（SQL構文化）とは別軸**
  - まずは“構文化”を立証し、その後に“複文可否（設定）”を追加で判定する

### 3) 黒箱で動的組立を見抜く観測（UI/HTTPからの境界推定）

#### 3.1 “ソート/フィルタ/ページング”は動的組立の温床
- 典型的に入力が構文側へ入りやすいパラメータ：
  - sort / order / direction / columns / fields / q / filter / where / ids / limit / offset / pageSize
- 観測の要点：
  - 値が増えるとSQL実行計画・レスポンス時間が変わる（ただし時間差はノイズが大きいので単独証拠にしない）
  - エラーが出るなら、**同じエンドポイントで“1変数だけ”揺らして差分**を取る

#### 3.2 “INリスト”と“可変条件”の組立臭
- INリスト：
  - 安全：`IN (?, ?, ?)` のように要素数分プレースホルダが増える（黒箱では直接見えない）
  - 危険：`IN (${csv})` のようにCSV文字列を組立している（数が増えるほどエラー差分が出やすい）
- 可変条件（WHERE断片）：
  - ORMの `raw` / `literal` / `where: sequelize.literal(...)` 等が入ると、入力が断片化して混ざる

#### 3.3 エラーは「漏えい」と「オラクル」の両面で観測点
- 観測するもの（最小）：
  - HTTPステータス、エラーコード、メッセージの有無、レスポンスサイズ、レスポンス時間
  - 同一入力を繰り返した時の揺れ（再現性）
- MySQLらしさのヒント（ただし決め打ちしない）：
  - 文言に “MySQL”, “MariaDB”, “You have an error in your SQL syntax” 等が出るケース
  - ただしフレームワークがメッセージを置換するので、**差分観測が本体**

### 4) プレースホルダの“安全神話”を壊す観測（守れていない箇所を見つける）

- 守れている：値はバインドされ、クォートや演算子として解釈されない
- 守れていない（MySQLで頻出）：
  1) **プレースホルダにできない構文要素**（列名・テーブル名・ソート方向・演算子・関数名）を入力で渡している
  2) “LIKEの%”や“INリスト”などの都合で、SQL文字列側で連結している
  3) エミュレートドプリペア等で、結局クライアント側で文字列展開している（設定依存）
  4) “安全なクエリ＋危険な断片”の混在（WHERE断片、ORDER断片）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - 同一エンドポイントで、1つの入力だけを変え、その入力の変化に対し、**SQLパーサ由来の差分**（構文エラー／型エラー／演算子解釈差／コメントによる後続無効化差）が再現する場合、黒箱でも"構文化"を主張しやすい
  - 入力位置（文字列/数値/識別子/断片）を推定できる
  - `#` コメントやバッククォート、MySQL特有の文言など、**複数の根拠が一致**したときに初めて「MySQL（互換）」を主張できる
  - 観測上、値のバインドっぽい挙動でも、次が見えたら危険領域が残る：sort/direction/fields/limit 等が効いている（＝構文側が動いている）、一部入力だけが"別扱い"になり、エラー差分が出る（＝断片が混ざっている）、例外が"SQL構文"に寄る（＝文字列連結でSQLを組立している可能性）
- 何が"推定"できるか（推定の根拠/前提）：
  - 方言当ては目的ではなく、**検証の当て込み（成立根拠）**に使う
  - ただし、アプリ層でエラーメッセージが加工されると"方言当て"は難しい
- 何は"言えない"か（不足情報・観測限界）：
  - "データが抜ける"断定（影響は契約・権限・DB権限で大きく変わる）
  - "複文が可能"断定（MySQLはドライバ設定に依存）
  - "DBがMySQL"断定（互換DB/抽象化/エラー隠蔽がある）
  - 単発の500や単発の遅延だけでは主張しない（ネットワーク、バックエンド混雑、アプリ例外が混ざる）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：SQLiがある → 同一エンドポイントで、1つの入力だけを変え、その入力の変化に対し、**SQLパーサ由来の差分**（構文エラー／型エラー／演算子解釈差／コメントによる後続無効化差）が再現する
  - パターンB：MySQL方言 → `#` コメントやバッククォート、MySQL特有の文言など、**複数の根拠が一致**したときに初めて「MySQL（互換）」を主張できる
  - パターンC：プレースホルダがあるから安全を否定できる → sort/direction/fields/limit 等が効いている（＝構文側が動いている）、一部入力だけが"別扱い"になり、エラー差分が出る（＝断片が混ざっている）、例外が"SQL構文"に寄る（＝文字列連結でSQLを組立している可能性）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）

> 本章は「悪用手順」を書くのではなく、ペンテストの意思決定（優先順位付けと、次に何を確かめるべきか）を明文化する。

### 1) 優先度が上がる“入口”（MySQLで実務的に刺さりやすい）

- 管理画面の検索/一覧（sort/filter/page）
- 複雑なレポート・エクスポート（列選択、並べ替え、集計条件）
- マルチテナント（tenant_id / org_id）で、条件断片が増える箇所
- “柔軟検索”を謳う機能（where=... のような DSL を受ける設計）

理由：
- これらは「仕様上、SQL構文を動的にする誘惑」が強い
- その結果、プレースホルダで守れない領域（識別子/断片）に入力が入りやすい

### 2) MySQLにおける“成立根拠”の作り方（差分を設計する）

- まず狙うのは「構文が壊れる/変わる」差分（低ノイズ）
  - 文字列コンテキスト：クォートの整合、エスケープの有無
  - 数値コンテキスト：数値以外の扱い（型エラー/暗黙変換）
  - 識別子コンテキスト：バッククォート等で崩れ方が変わる
  - 断片コンテキスト：演算子やAND/ORの解釈差が出る
- 次に狙うのは「実行が変わる」差分（時間・内容差）
  - ただし時間差はノイズが大きいので、**最小遅延・複数回一致**を原則とする

### 3) 方言差分を“検証設計”に使う（Oracle/PostgreSQL/MSSQLとの比較）

- Oracleとの差分（成立根拠として使う）：
  - 連結：Oracleは `||` が中心、MySQLは `CONCAT()` が中心
  - ダミーテーブル：Oracleは DUAL、MySQLは必須ではない
  - したがって、Oracleの当て込みで効いたテストがMySQLで外れるのは自然  
    → “外れた＝安全”ではない（方言差を疑う）
- PostgreSQLとの差分：
  - Postgreは `::` 型キャストや `pg_sleep` などが象徴
  - MySQLは暗黙変換が多く、型エラーの出方が違う（成立根拠の取り方が違う）
- MSSQLとの差分：
  - MSSQLはバッチ境界の文化が強いが、MySQLは**ドライバ設定**が支配的
  - よって “複文での影響拡大” は最後に確認（先に構文化を確定）

### 4) 防御側の観点（攻撃者が嫌がる設計に落とす）

- 動的組立を許すなら、入力は“SQL文字列”ではなく“選択肢”に落とす（allowlist）
- 例：
  - sort=createdAt → `ORDER BY created_at`
  - direction=desc|asc の2択
  - limit は上限固定（max 100 等）
  - fields は許可列の集合からサーバ側で組立（入力値を列名として使わない）
- そして“設定境界”を閉じる：
  - MySQLドライバの multi-statements を無効
  - ORMの raw/literal を禁止 or 封じ込め（レビュー対象に）

## 次に試すこと（仮説A/Bの分岐と検証）

### 全体方針：小さく確かめ、境界を固定し、根本原因まで落とす

- 1回で“完全証明”しない。  
  「この入力はSQL“値”に入る」/「この入力はSQL“構文”に入る」をまず確定し、その後に影響へ進む。

### 仮説A：動的組立（構文側）に入力が混ざっている

#### A-1) ソート/ページングを起点に“構文コンテキスト”を確定する
- 対象パラメータ：sort / order / dir / limit / offset / fields / columns
- 観測設計：
  - 正常値（想定どおり動く）をベースラインにする
  - 1項目ずつ変え、次を記録：
    - ステータス、レスポンスサイズ、エラー文言の有無、レスポンスタイム
- 期待する根拠（例）：
  - sortの値が変わると結果順が変わる → **ORDER BYが動的**
  - limitが大きいと遅い／小さいと速い → **LIMITが動的**（ただしノイズ注意）
  - 不正な列名で“SQL由来のエラー差分” → **列名がそのまま入っている可能性**

#### A-2) “allowlist不在”を疑う指標（設計起因の脆弱性）
- sort=任意文字列でも受理される
- fields=任意の列名が通る（あるいは通ったり落ちたりする）
- where=のような自由入力DSLがある
- GraphQLのorderBy等で、列名がユーザ指定になっている

#### A-3) レポートに落とす根本原因（修正可能な形）
- “SQLi”を一言で終わらせず、どの境界が破れているかを書く：
  - 例：ORDER BY の識別子（列名）を入力値で組立している（プレースホルダ不可領域）
  - 例：INリストをCSV文字列連結で組立している（可変プレースホルダ未使用）
  - 例：ORMの raw 断片に入力が流入している（literal/fragment）

### 仮説B：値はプレースホルダで守れている（ただし“穴”が残る可能性）

#### B-1) プレースホルダが効いている時の観測（安全側の根拠）
- 入力に“構文っぽい文字”を含めても、構文エラー差分が出ない
- エラーが出るとしても、アプリ側のバリデーション（400等）で止まる
- 同じ入力変化で結果が“論理的に”変わる（検索語の一致など）だけで、異常差分がない

#### B-2) それでも残りがちな穴（MySQLで頻出）
- LIKE検索で `%{q}%` をSQL文字列側で連結している（値境界のはずが崩れる）
- INリストの要素数が可変で、文字列連結している
- LIMIT/OFFSET を文字列連結している（数値だから安全、が崩れる）
- JSON検索や正規表現検索で、式（関数引数）が断片化している

#### B-3) “修正済みの確認”まで含めた検証
- 修正後は、同じ観測設計で差分が消えることを確認する
- さらに設定境界（multi-statements無効、ORM raw禁止）も固定したかを確認する

### 仮説C：複文（stacked queries）が成立する（影響拡大の別軸）

- MySQLはドライバ設定で成立するため、主張には根拠が必要：
  - 例：アプリが `multipleStatements` 相当を有効化している、など（可能なら設定根拠）
- 黒箱での注意：
  - “複文を試す”検証は影響が大きくなりやすい  
    → 契約範囲と安全性（破壊的操作の回避）を優先し、**必要最小限**にする

### 具体例（最小限の例示：意味→判断→次の一手）

> ここでは「どの形が危険か」を理解するための“形”だけを示す。実際の送信は必ず許可された検証環境・契約範囲で行う。

~~~~
# 危険：動的ORDER BY（列名はプレースホルダ化できない）

SELECT * FROM items ORDER BY {sort} {dir} LIMIT ?

# 安全：入力は選択肢→サーバ側で列名にマップ

sort=createdAt|price|name のように受け、サーバで
createdAt -> created_at
price     -> price
name      -> name
に変換してSQL文字列を生成する（入力値をそのまま入れない）
~~~~

~~~~
# 危険：INリストをCSVで連結

SELECT * FROM items WHERE id IN ({csv_ids})

# 安全：要素数分プレースホルダを展開

SELECT * FROM items WHERE id IN (?, ?, ?, ...)
~~~~

~~~~
# 危険：LIKEの%をSQL文字列側で連結（断片化）

... WHERE name LIKE '%" + q + "%'

# 安全：%を含めて値としてバインド

... WHERE name LIKE ?
param = "%" + q + "%"
~~~~
- この例で観測していること：
  - プレースホルダ（Prepared Statement）で守れている範囲／守れていない範囲を切り分ける、守れていない典型である **動的SQL組立（ORDER/LIMIT/IN/識別子/断片）** を、黒箱でも差分観測で特定する
- 出力のどこを見るか（注目点）：
  - 同一エンドポイントで、1つの入力だけを変え、その入力の変化に対し、**SQLパーサ由来の差分**（構文エラー／型エラー／演算子解釈差／コメントによる後続無効化差）が再現するか、入力位置（文字列/数値/識別子/断片）を推定できるか
- この例が使えないケース（前提が崩れるケース）：
  - 単発の500や単発の遅延だけでは主張しない（ネットワーク、バックエンド混雑、アプリ例外が混ざる）

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - `04_labs/02_web/05_input/03_sql_injection/02_mysql_dynamic_assembly/`
- 取得する証跡（目的ベースで最小限）：
  - Proxyログ（入力がどのAPI/画面で送られ、どのレスポンス（または後続表示）で反映されたか）
  - 必要時：アプリ例外ログ、入口ログ、クラウド監査ログ（例外の相関）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
~~~~
# 危険：動的ORDER BY（列名はプレースホルダ化できない）

SELECT * FROM items ORDER BY {sort} {dir} LIMIT ?

# 安全：入力は選択肢→サーバ側で列名にマップ

sort=createdAt|price|name のように受け、サーバで
createdAt -> created_at
price     -> price
name      -> name
に変換してSQL文字列を生成する（入力値をそのまま入れない）

# 危険：INリストをCSVで連結

SELECT * FROM items WHERE id IN ({csv_ids})

# 安全：要素数分プレースホルダを展開

SELECT * FROM items WHERE id IN (?, ?, ?, ...)

# 危険：LIKEの%をSQL文字列側で連結（断片化）

... WHERE name LIKE '%" + q + "%'

# 安全：%を含めて値としてバインド

... WHERE name LIKE ?
param = "%" + q + "%"
~~~~
- この例で観測していること：
  - プレースホルダ（Prepared Statement）で守れている範囲／守れていない範囲を切り分ける、守れていない典型である **動的SQL組立（ORDER/LIMIT/IN/識別子/断片）** を、黒箱でも差分観測で特定する
- 出力のどこを見るか（注目点）：
  - 同一エンドポイントで、1つの入力だけを変え、その入力の変化に対し、**SQLパーサ由来の差分**（構文エラー／型エラー／演算子解釈差／コメントによる後続無効化差）が再現するか、入力位置（文字列/数値/識別子/断片）を推定できるか
- この例が使えないケース（前提が崩れるケース）：
  - 単発の500や単発の遅延だけでは主張しない（ネットワーク、バックエンド混雑、アプリ例外が混ざる）

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V5（入力検証、サニタイズ、エンコーディング）、V7（ログとモニタリング）、V9（データ保護）、V12（ファイルとリソース）
  - 該当要件（可能ならID）：V5.1（入力検証）、V7.1（ログ要件）、V9.1（データ保護）、V12.1（ファイルアップロード）
  - このファイルの内容が「満たす/破れる」ポイント：SQLi（CWE-89）を「入力→SQL構文」越境として防ぐ（主に検証・サニタイズ・エンコード／安全なクエリ機構／エラーハンドリング／最小権限）。パラメータ化（プレースホルダ）を"万能薬"にせず、**動的SQL組立（ORDER/LIMIT/IN/識別子/断片）**の境界を別枠で制御する。DBコネクタ設定（例：multi-statements）を"境界条件"として固定し、攻撃面を縮退させる。例外・エラー差分を「存在オラクル／型オラクル／実装漏えい」にしない（観測点の縮退）。
- WSTG：
  - 該当カテゴリ/テスト観点：Injection Testing（SQLi）、Error Handling Testing、Authorization Testing、Business Logic Testing、Logging Testing
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：WSTG-INPV-05（Testing for SQL Injection）を中核に、入力点ごとのコンテキスト（文字列/数値/識別子/式）を確定し、差分観測で成立根拠を固める。入力点ごとにコンテキストを確定（文字列/数値/識別子/断片）、MySQL方言（コメント/識別子クォート/SQL MODE/複文設定）を"成立根拠"として使う。
- PTES：
  - 該当フェーズ：Information Gathering、Vulnerability Analysis、Exploitation
  - 前後フェーズとの繋がり（1行）：Vulnerability Analysis（入力点→SQL境界の同定、方言差分の当て込み、再現性のある最小差分PoC）→ Exploitation（契約範囲内で影響（読み取り/改ざん/認可迂回）を"必要最小限"で実証（過剰なデータ抽出は避ける））→ Reporting（根本原因（動的組立・コネクタ設定・ORM誤用）と修正指針（設計変更）をセットで提示）。動的組立の同定、方言差分での当て込み、差分観測での立証。
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：TA0001（Initial Access）、TA0009（Collection）、TA0006（Credential Access）、TA0005（Defense Evasion）
  - 攻撃者の目的（この技術が支える意図）：TA0001 Initial Access / TA0009 Collection / TA0006 Credential Access（アプリDBに資格情報がある場合）/ TA0005 Defense Evasion（エラー差分を利用した低ノイズ探索）。代表例：T1190 Exploit Public-Facing Application（SQLiは典型的な入口）。Discovery/Collectionへ連鎖し得るが、レポートは"到達可能性"と"前提（権限・設定）"を分離して記述する。

## 参考（必要最小限）
- OWASP Web Security Testing Guide - Testing for SQL Injection  
  https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection
- OWASP Cheat Sheet Series - SQL Injection Prevention Cheat Sheet  
  https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
- OWASP Top 10 2021 - A03 Injection（背景整理）  
  https://owasp.org/Top10/2021/A03_2021-Injection/
- IPA（参考：プレースホルダ/動的組立のリスク整理に有用）  
  https://www.ipa.go.jp/security/vuln/ps6vr70000011hc4-att/000017321.pdf

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/05_input_03_sql_injection_01_oracle（境界_プレースホルダ_ORM）.md`
- `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
- `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`

---

## 深掘りリンク（最大8）
- 関連 topics：
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/05_input_03_sql_injection_01_oracle（境界_プレースホルダ_ORM）.md`
  - `01_topics/02_web/05_input_03_sql_injection_03_postgre（境界_プレースホルダ_型キャスト）.md`
  - `01_topics/02_web/05_input_03_sql_injection_04_mssql（境界_プレースホルダ_バッチ境界）.md`
  - `01_topics/02_web/04_api_03_rest_filters_検索・ソート・ページング境界.md`
  - `01_topics/02_web/04_api_09_error_model_情報漏えい（例外_スタック）.md`
- 関連 labs / cases：
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
