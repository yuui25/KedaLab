# 06_config_01_CORSと信頼境界（Origin_資格情報_プリフライト）
CORSを「許可されている/されていない」ではなく、**どのOriginに・どの条件（資格情報・メソッド・ヘッダ）で・何が許可されるか**を観測→差分で説明できる

---

## 目的（この技術で到達する状態）
- CORSを「許可されている/されていない」ではなく、**どのOriginに・どの条件（資格情報・メソッド・ヘッダ）で・何が許可されるか**を観測→差分で説明できる。
- CORSと認証/認可を混同せず、**"ブラウザが読み取れるか"の境界**として整理し、結論（成立・不成立・不明）を根拠付きで出せる。
- 誤設定の典型（ワイルドカード、反射、資格情報との矛盾、プリフライトの穴）を、最小の検証で切り分けられる。

## 前提（対象・範囲・想定）
- 対象：ブラウザからAPIを呼ぶ構成（SPA/フロント分離）または外部サイトからアクセスされ得るAPI。
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - CDN/WAF、SaaS連携、SPA+API、クラウド（AWS/Azure）前提
- できること/やらないこと（安全に検証する範囲）：
  - やる：観測→差分で根拠を固める。差分比較（条件A/B）で成立条件を切ることで、推測を排して報告品質を上げる（再現・根拠提示が必須）
  - やらないこと：推測で断言しない。ブラウザDevTools（CORSブロックの表示は"結果"、根拠は通信ヘッダ）のみに依存しない
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
  - `01_topics/02_web/04_api_01_権限伝播モデル（フロント_バックエンド_ジョブ）.md`
  - `01_topics/02_web/06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：
    - CORSが決めるのは「読み取り許可」（サーバが"リクエストを受けるか"ではなく、**ブラウザがレスポンスを"読み取ってよいか"**を制御する）
    - 主要ヘッダ（リクエスト側：Origin、Access-Control-Request-Method、Access-Control-Request-Headers、レスポンス側：Access-Control-Allow-Origin、Access-Control-Allow-Credentials、Access-Control-Allow-Methods、Access-Control-Allow-Headers、Access-Control-Expose-Headers、Vary: Origin）
    - 誤設定の典型（ワイルドカード、反射、資格情報との矛盾、プリフライトの穴）
  - 扱わない（別ユニットへ接続）：
    - CORSの詳細な仕様説明（本プロジェクトは境界と成立根拠を優先）

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - リクエスト側：Origin、Access-Control-Request-Method（プリフライト時）、Access-Control-Request-Headers（プリフライト時）
  - レスポンス側：Access-Control-Allow-Origin（ACAO）、Access-Control-Allow-Credentials（ACAC）、Access-Control-Allow-Methods（ACAM）、Access-Control-Allow-Headers（ACAH）、Access-Control-Expose-Headers、Vary: Origin（キャッシュ境界の重要ポイント）
  - Proxyログ（必須）：レスポンスヘッダ、OPTIONSプリフライト、要求ヘッダ/Origin
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：どのOriginのブラウザにレスポンスの読み取りを許すか
  - 信頼境界（外部連携・第三者・越境ポイント）：CORSは、サーバが"リクエストを受けるか"ではなく、**ブラウザがレスポンスを"読み取ってよいか"**を制御する。そのため、APIが200を返していても、ブラウザが読めない場合がある（逆もある）
  - 権限境界（権限の切替/伝播/委任）：Cookie等の資格情報付きの読み取りを許可するか（ACAC）
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - Allow-Origin（ACAO）：固定の許可Origin、`*`（資格情報を伴わない読み取りを広く許可する方向）、反射（リクエストのOriginをそのまま返すように見える：境界が崩れている可能性）
  - Allow-Credentials（ACAC）：`true` の場合、許可Originが"厳密に限定されているか"が重要。`ACAO:*` と `ACAC:true` の組み合わせは矛盾しやすく、挙動は実装依存になりがち（推測せず観測）
  - プリフライト（OPTIONS）：非単純リクエスト（特定メソッド/ヘッダ）では、本体の前にOPTIONSで許可を取りに行く。本体（GET/POST）が許可されていても、プリフライトが拒否されるとブラウザは呼べない
  - Vary: Origin（キャッシュ境界）：Originごとにレスポンスを分けてキャッシュすべきことを示す。Varyが無いと、キャッシュ経由で別Originの許可が混ざる可能性（構成依存）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - どのOriginに読み取りを許可しているか（固定/ワイルド/反射の差分）
  - 資格情報付き読み取りが許可されるか（ACAC）
  - プリフライトで許可されるメソッド/ヘッダ（ACAM/ACAH）
  - キャッシュ境界が考慮されているか（Vary: Origin）
- 何が"推定"できるか（推定の根拠/前提）：
  - 実際に第三者がデータを取得できるかの可能性（認証・認可の成立条件が必要）
  - CDN/キャッシュ経由の混在影響（構成・キャッシュ挙動の追加観測が必要）
- 何は"言えない"か（不足情報・観測限界）：
  - 実際に第三者がデータを取得できるかの確定（認証・認可の成立条件が必要）
  - CDN/キャッシュ経由の混在影響（構成・キャッシュ挙動の追加観測が必要）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：固定の許可Origin（健全） → 設計意図が比較的明確（ただし範囲が妥当かは別）
  - パターンB：反射（リクエストのOriginをそのまま返すように見える） → 境界が崩れている可能性（差分で確定）
  - パターンC：`ACAO:*` と `ACAC:true` の組み合わせ → 矛盾しやすく、挙動は実装依存になりがち（推測せず観測）

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - 読み取り可能性が高いデータ系API（ユーザ情報、検索、一覧、エクスポート）
  - 資格情報（Cookie）を伴うAPI（ACAC:true との組み合わせを要観測）
  - 例外経路（ファイル、エクスポート、管理系API）でCORSだけ緩い箇所
- 優先度の付け方（時間制約がある場合の順序）：
  1) 読み取り可能性が高いデータ系API（ユーザ情報、検索、一覧、エクスポート） → 最優先で重大
  2) 資格情報（Cookie）を伴うAPI（ACAC:true との組み合わせを要観測） → 信頼境界が崩れる可能性
  3) 例外経路（ファイル、エクスポート、管理系API）でCORSだけ緩い箇所 → 攻撃価値が高い
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：もし反射に見えるなら：Origin A/Bで差分を取り、境界が存在するか確定する
  - 攻め筋2：もしACAC:trueなら：Cookieの送信境界（SameSite/Domain）と合わせて成立条件を切る
  - 攻め筋3：もしVaryが無いなら：キャッシュ混在の可能性を"観測"で潰す（断言しない）
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - CORSが許可されている＝「第三者がAPIを呼べる」ではない。呼べる/呼べないは認証・認可・到達性の問題。CORSは"ブラウザの読み取り"の問題。
  - CORSがブロックされる＝「安全」ではない。ブラウザ以外（サーバ/ツール）はCORSに縛られない。読み取りが防げても、状態変更は別途検討が必要。

## 次に試すこと（仮説A/Bの分岐と検証）
- 仮説A：CORSが広すぎる気がする
  - 成立条件：
    - データ系エンドポイントで、Originを複数で差分観測（固定/反射/ワイルド）を確定する必要がある
  - 次の検証：
    - データ系エンドポイントを選び、Originを複数で差分観測（固定/反射/ワイルド）を確定する
    - **Originを2種類以上**に変えて比較する（許可/不許可の境界があるか）
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功："どのOriginが許可されるか"を yes/no/unknown で言える
    - 失敗：固定の許可Originが確認でき、設計意図が比較的明確
- 仮説B：Cookie付きで読めるかが焦点
  - 成立条件：
    - ACAC:true との組み合わせを要観測する場合
  - 次の検証：
    - ACACとSameSiteの両方を観測し、ブラウザ条件（送信される/されない）を切り分ける
    - Cookie送信が絡むなら、SameSite/Domain設計（Authn）と合わせて成立条件を切る
  - 期待する観測：
    - 成功：読み取り成立の条件（ブラウザが送る/読める）が説明できる
    - 失敗：Cookie送信が適切に制御されている
- 仮説C：プリフライト周りだけ挙動が変
  - 成立条件：
    - 非単純リクエスト（特定メソッド/ヘッダ）で、本体の前にOPTIONSで許可を取りに行く場合
  - 次の検証：
    - OPTIONSの結果（許可/拒否）と本体APIの結果を並べ、どこで境界があるかを確定する
    - まず「単純リクエスト」で観測し、その後に「非単純（カスタムヘッダ等）」で差分を見る
  - 期待する観測：
    - 成功："プリフライトが境界"か"本体が境界"かを説明できる
    - 失敗：プリフライトと本体の挙動が一貫している

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- 取得する証跡（目的ベースで最小限）：
  - Proxyログ（必須）：レスポンスヘッダ、OPTIONSプリフライト、要求ヘッダ/Origin
  - 対象エンドポイント、Origin値（A/B）、返ってきたCORSヘッダ一式、401/403/200等の結果（認証・認可の結果は別途整理）
- 観測の取り方（どの視点で差分を見るか）：
  - 視点1：差分セット（最小）
    - Originなし（ツール/同一オリジン相当）でAPIを呼ぶ → レスポンスとヘッダを保存
    - Origin=A を付けて呼ぶ → ACAO/ACAC/Expose を保存
    - Origin=B（別ドメイン）を付けて呼ぶ → 差分を比較
    - 非単純リクエスト（例：カスタムヘッダ）を想定し OPTIONS を観測 → 許可/拒否を保存
  - 視点2：CDN/キャッシュがある場合は、同一エンドポイントでOrigin差分を繰り返して一貫性を確認する
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/cors_boundary 2>/dev/null
    cd ~/keda_evidence/cors_boundary
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **差分セット（最小）** のみ（推測で断言しない）
      - ブラウザDevTools（CORSブロックの表示は"結果"、根拠は通信ヘッダ）のみに依存しない
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host、User、Time、対象エンドポイント、Origin値（A/B）、返ってきたCORSヘッダ一式、401/403/200等の結果

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 目的：CORS許可の境界（Origin/credentials/プリフライト）を差分で確定する

# 差分セット（最小）
# 1) Originなし（ツール/同一オリジン相当）でAPIを呼ぶ → レスポンスとヘッダを保存
# 2) Origin=A を付けて呼ぶ → ACAO/ACAC/Expose を保存
# 3) Origin=B（別ドメイン）を付けて呼ぶ → 差分を比較
# 4) 非単純リクエスト（例：カスタムヘッダ）を想定し OPTIONS を観測 → 許可/拒否を保存

# 記録すべきもの
# - 対象エンドポイント
# - Origin値（A/B）
# - 返ってきたCORSヘッダ一式
# - 401/403/200等の結果（認証・認可の結果は別途整理）
~~~~

- この例で観測していること：
  - CORS許可の境界（Origin/credentials/プリフライト）を差分で確定する
- 出力のどこを見るか（注目点）：
  - Access-Control-Allow-Origin（ACAO）、Access-Control-Allow-Credentials（ACAC）、Access-Control-Allow-Methods（ACAM）、Access-Control-Allow-Headers（ACAH）、Access-Control-Expose-Headers、Vary: Origin
- この例が使えないケース（前提が崩れるケース）：
  - ブラウザ以外（サーバ/ツール）はCORSに縛られないため、ブラウザ経由での観測が必要

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V1（Architecture）/ V4（Access Control）/ V13（API）/ V7（Logging）
  - 該当要件（可能ならID）：CORSは"認可"ではなく、ブラウザに対する「読み取り許可」を設計する境界
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：CORS誤設定は「第三者サイトからの読み取り」を成立させる可能性がある。誤設定の典型（ワイルドカード、反射、資格情報との矛盾、プリフライトの穴）により、境界が崩れる。
    - 満たす：CORSは"認可"ではなく、ブラウザに対する「読み取り許可」を設計する境界として適切に設定する。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：設定・運用境界のテスト
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：設定・運用境界のテストで、CORSは頻出。誤設定は「第三者サイトからの読み取り」を成立させる可能性があるため、観測→差分で根拠を固める。
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：脆弱性分析
  - 前後フェーズとの繋がり（1行）：差分比較（条件A/B）で成立条件を切ることで、推測を排して報告品質を上げる（再現・根拠提示が必須）。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：Collection
  - 攻撃者の目的（この技術が支える意図）：CORS誤設定は、ブラウザを媒介にしたデータ取得（読み取り）に寄与し得る。
  - 参照：https://attack.mitre.org/tactics/TA0009/（Collection）

## 参考（必要最小限）
- 親：`01_topics/02_web/06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- 関連（Authn）：`01_topics/02_web/02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
- 観測：`04_labs/01_local/02_proxy_計測・改変ポイント設計.md`

## リポジトリ内リンク（最大3つまで）
- 関連 topics：`06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- 関連 topics：`02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
- 関連 labs：`04_labs/01_local/02_proxy_計測・改変ポイント設計.md`

---

## 深掘りリンク（最大8）
- `06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- `02_authn_01_cookie属性と境界（Secure_HttpOnly_SameSite_Path_Domain）.md`
- `04_api_01_権限伝播モデル（フロント_バックエンド_ジョブ）.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `05_input_19_cache_poisoning_01_keying（vary_normalization）.md`
- `05_input_20_crlf_injection_01_response_splitting（header_body）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`
- `04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`

---
