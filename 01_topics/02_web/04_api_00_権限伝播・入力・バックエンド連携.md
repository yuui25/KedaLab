# 04_api_00_権限伝播・入力・バックエンド連携

## 目的（この技術で到達する状態）
- APIを「エンドポイント列挙」ではなく、**権限がどこから来て、どこで判定され、どこまで伝播するか**（境界）として理解し、検証に使える。
- SPA/モバイル/サーバ間通信など利用形態の違いを踏まえ、**本当に効く入力点**（URL/Body/Header/Token/GraphQL variables 等）を特定できる。
- “成功/失敗”の判定をレスポンスだけに頼らず、**状態確認（再取得/一覧/監査/副作用）**まで含めて再現手順を作れる。

## 00/01の役割分担（最小）
- 00：全体像・用語・境界の読み方（権限伝播の共通モデル）
- 01：具体的な伝播モデル（直通/変換/ジョブ）と差分観測の進め方

## 優先度基準（P0/P1/P2）
- P0：越境/権限不一致で他人データ取得や重要操作が成立、または成立条件が明確
- P1：境界が揺れている兆候があり、誤設定/例外パスで成立し得る
- P2：設計は堅牢だが監査や運用が弱く、事故時の追跡が困難

## 前提（対象・範囲・想定）
- 対象：許可された範囲の API（REST/GraphQL/WebSocket/内部API含む）に限定。
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - SPA + API、モバイル + API、マイクロサービス、API Gateway、BFF（Backend for Frontend）
  - 認証：Cookie/Token（Bearer/JWT等）、SSO前提のことがある
  - 外部依存：SaaS/外部API（決済、通知、ストレージ、分析、IdP等）
- できること/やらないこと（安全に検証する範囲）：
  - できること：代表機能を1つ選び、API入口、必須の鍵、境界に効く入力点、状態確認の方法を揃える
  - やらないこと：ツールでの大量自動列挙を前提にしない（まず"境界モデル"を確定してから最小限の探索にする）、すべてのAPIの網羅（代表機能から広げる必要がある）、内部実装（ソース/設計）がない状態での断定（観測からの推定に留める）、外部連携の詳細（契約/設定）は観測だけでは見えない場合がある
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/02_authn_00_認証・セッション・トークン.md`
  - `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
### 1) APIの入口（Entry）を確定する
- どのホスト/パスが API か（例：api. / /api/v1 / /graphql / /ws など）
- 画面操作1つに対して、どのAPIが呼ばれるか（代表機能を1つ選ぶ）
- “入口の種類”を分類する
  - 読む（GET/Query）
  - 書く（POST/Mutation）
  - 消す（DELETE）
  - 実行（アクション系：/execute /approve など）

### 2) 権限伝播（AuthZの“材料”がどこから来るか）
- 伝播の材料（観測で確定）
  - Cookie（セッションID 等）
  - Authorization ヘッダ（Bearer 等）
  - トークン内の claim（tenant/role/scope）
  - リクエストヘッダ（X-Role/X-Tenant 等：あれば）
- “判定がどこで行われるか”を推定する
  - API Gateway / BFF / サービス内 / 下流サービス
  - ヒント：エラー型、レスポンス時間、共通の拒否パターン、ヘッダの有無

### 3) 入力点（どこが境界を変えるか）
- URL/Path/Query：リソースID、フィルタ、ページング、ソート
- Body（JSON/Form）：ownerId、tenantId、role、status 等の“境界に効きそうな値”
- Header：Origin、Content-Type、X-* 系
- GraphQL：query/mutation、variables、node id、fragments
- WebSocket：初回認証、イベント名、payloadの構造

### 4) 出力（レスポンス）の読み方（“状態”で判断する）
- ステータスコードの意味（401/403/404/200等）は入口だが、結論にしない
- 状態確認（必須）
  - 書いたなら：再取得（GET）で本当に反映したか
  - 消したなら：一覧/参照/検索で本当に消えたか
  - 実行系なら：副作用（通知/ログ/履歴/ステータス）が変わったか
- 部分成功/部分失敗の兆候
  - 返却フィールド欠落、件数の変化、サーバ側で正規化される等

### 5) 外部連携（越境点）を見つける
- 外部API/SaaSへの呼び出しが存在するか（フロント/バックから）
- 連携の境界
  - どのデータが外に出るか（個人情報、契約情報、ファイル等）
  - どの権限で呼ばれるか（ユーザ委任/サーバ権限）
- 連携失敗時の挙動（フェイルオープン/リトライ/キュー等）を“状態”として観測する

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - API入口（代表機能）に対し、必要な"鍵"（Cookie/Token/ヘッダ）が何か
  - 境界に効く入力点（ID/tenant/role/owner等）がどこに存在するか
  - 認可がサーバ側で強制されているか（AuthZの強制点の推定）
  - 成否判定が"状態確認"で再現できる
- 何が"推定"できるか（推定の根拠/前提）：
  - Gateway/BFF/下流サービスのどこで判定されているか
  - 外部連携（SaaS/外部API）の越境点と責任分界
- 何は"言えない"か（不足情報・観測限界）：
  - すべてのAPIの網羅（代表機能から広げる必要がある）
  - 内部実装（ソース/設計）がない状態での断定（観測からの推定に留める）
  - 外部連携の詳細（契約/設定）は観測だけでは見えない場合がある
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：APIの認可判定がフロント寄りで、バックエンドが甘い → UI制御だけか、サーバで強制されているかが分かる（AuthZの強制点が見える）
  - パターンB：境界値が複数箇所にあり、真の境界が分からない（tenant/owner等） → どの入力点が"効いている"かが確定し、AuthZ検証が最短距離になる
  - パターンC：外部連携があり、失敗時挙動が境界を崩す可能性がある → フェイル挙動（止まる/通る/遅延/再試行）を"状態"として説明できる

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
### 優先度の付け方（最短で価値が出る順）
1) 権限が関わる“書く/消す/実行”のAPI（影響が明確）
2) テナント境界が絡むAPI（越境の重大度が高い）
3) オブジェクト境界が絡むAPI（BOLA/IDORの主戦場）
4) 外部連携を含むAPI（越境・責任分界・フェイル挙動が複雑）

### 攻め筋（APIでよく効く判断）
- “鍵”が1つでも欠けるとどうなるか（401/403だけでなく状態がどうなるか）
- “境界値”を変えるとどこで拒否されるか（URL/Body/Header/Tokenのどれが真の境界か）
- “状態確認”ができる観測点を用意しているか（再現性の鍵）

### 次の仮説に繋げる（API → 入力/設定へ）
- API入口と境界が固まったら、次に進む方向を決める
  - 入力→実行境界（テンプレ/デシリアライズ等）：`01_topics/02_web/05_input_入力→実行境界（テンプレ/デシリアライズ等）.md`
  - 設定・運用境界（CORS/ヘッダ/Secrets）：`01_topics/02_web/06_config_設定・運用境界（CORS ヘッダ Secrets）.md`
  - SaaS連携（IdP/共有/監査）：`01_topics/04_saas/01_idp_連携（SAML OIDC OAuth）と信頼境界.md`

## 次に試すこと（仮説A/Bの分岐と検証）
### 共通の最小セット（代表機能1つで始める）
- 代表機能を1つ選び、次の4点を揃える
  - 入口API（読む/書くの最低1つずつ）
  - 必須の鍵（Cookie/Token/ヘッダ）
  - 境界に効く入力点（ID/tenant/role等）
  - 状態確認の方法（再取得/一覧/履歴）
- 証跡は固定
  - HAR、Proxyログ、検証メモ（主体/対象/操作/条件/結果/状態確認）

### 仮説A：APIの認可判定がフロント寄りで、バックエンドが甘い
- 検証（A/B）
  - A：UIから通常操作（正規リクエスト）を観測
  - B：Proxyで“境界に効きそうな入力”だけ変えて再送し、サーバで拒否されるかを確認
- 期待する観測
  - UI制御だけか、サーバで強制されているかが分かる（AuthZの強制点が見える）

### 仮説B：境界値が複数箇所にあり、真の境界が分からない（tenant/owner等）
- 検証（A/B）
  - A：境界値を1箇所だけ変更（例：URLのIDだけ）
  - B：別箇所だけ変更（例：BodyのownerIdだけ）
- 期待する観測
  - どの入力点が“効いている”かが確定し、AuthZ検証が最短距離になる

### 仮説C：外部連携があり、失敗時挙動が境界を崩す可能性がある
- 検証（A/B）
  - A：連携が成功する条件で操作し、状態確認を記録
  - B：連携が失敗する条件（許可範囲で）を作り、状態がどう変わるかを観測
- 期待する観測
  - フェイル挙動（止まる/通る/遅延/再試行）を“状態”として説明できる

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/` ）：
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
- 取得する証跡（目的ベースで最小限）：
  - HAR、Proxyログ、検証メモ（主体/対象/操作/条件/結果/状態確認）
- 観測の取り方（どの視点で差分を見るか）：
  - 代表機能を1つ選び、次の4点を揃える：入口API（読む/書くの最低1つずつ）、必須の鍵（Cookie/Token/ヘッダ）、境界に効く入力点（ID/tenant/role等）、状態確認の方法（再取得/一覧/履歴）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
~~~~
# 例：APIの鍵が何かを観測（401/403/200の差分を見る入口）
curl -i "https://example.com/api/me"

# 例：同一操作で入力点だけ変えて差分観測（概念例）
curl -i -H "Authorization: Bearer <TOKEN>" "https://example.com/api/orders/1001"
curl -i -H "Authorization: Bearer <TOKEN>" "https://example.com/api/orders/1002"
~~~~
- この例で観測していること：
  - API入口（代表機能）に対し、必要な"鍵"（Cookie/Token/ヘッダ）が何か、境界に効く入力点（ID/tenant/role/owner等）がどこに存在するか
- 出力のどこを見るか（注目点）：
  - ステータスコード（401/403/404/200等）、状態確認（再取得/一覧/履歴）、部分成功/部分失敗の兆候（返却フィールド欠落、件数の変化、サーバ側で正規化される等）
- この例が使えないケース（前提が崩れるケース）：
  - 主役はコマンドではなく「何を固定し、何を変えるか（差分設計）」と「状態確認」

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V4（認証・セッション管理）、V5（アクセス制御）、V6（入力検証）
  - 該当要件（可能ならID）：V4.2（セッション管理）、V5.1（一般的なアクセス制御設計）、V6.1（入力検証）
  - このファイルの内容が「満たす/破れる」ポイント：APIの認証・認可・入力・出力・設定を"境界"として扱い、満たす/破れる点を検証で説明できる状態にする
- WSTG：
  - 該当カテゴリ/テスト観点：API Testing
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：API Testing の観点を、入口観測→鍵の特定→入力点→状態確認へ落とし込む。APIはWeb機能の実体であり、他の観点（AuthZ/Input/Config）を成立させる前提になる。
- PTES：
  - 該当フェーズ：Intelligence Gathering、Vulnerability Analysis、Exploitation
  - 前後フェーズとの繋がり（1行）：Intelligence Gathering の観測を、Vulnerability Analysis（優先度付け）へ接続し、Exploitation へ最短で繋ぐ
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：TA0007（Discovery）、TA0009（Collection）、TA0010（Exfiltration）、TA0004（Privilege Escalation）
  - 攻撃者の目的（この技術が支える意図）：Discovery/Collection/Exfiltration などの目的に対し、APIが"データ面・権限面の主戦場"になっている構造を説明できる状態にする

## 参考（必要最小限）
- OWASP ASVS（APIの認証・認可・入力・出力・設定）
- OWASP WSTG（API Testing）
- PTES（Intelligence Gathering、Vulnerability Analysis、Exploitation）
- MITRE ATT&CK（Discovery、Collection、Exfiltration、Privilege Escalation）

## リポジトリ内リンク（最大3つまで）
- `01_topics/02_web/02_authn_00_認証・セッション・トークン.md`
- `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
- `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`

---

## 深掘りリンク（最大8）
- 関連 topics：
  - `01_topics/02_web/02_authn_00_認証・セッション・トークン.md`
  - `01_topics/02_web/03_authz_00_認可（IDOR BOLA BFLA）境界モデル化.md`
  - `01_topics/02_web/04_api_01_権限伝播モデル（フロント_バックエンド_ジョブ）.md`
  - `01_topics/02_web/05_input_00_入力→実行境界（テンプレ デシリアライズ等）.md`
  - `01_topics/02_web/06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- 関連 labs / cases：
  - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
  - `04_labs/01_local/03_capture_証跡取得（pcap/har/log）.md`
