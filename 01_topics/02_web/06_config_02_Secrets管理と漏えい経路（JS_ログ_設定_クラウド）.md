# 06_config_02_Secrets管理と漏えい経路（JS_ログ_設定_クラウド）
"Secretsっぽい文字列"を見つけた段階で止まらず、**それが本当に秘密情報か／有効か／どこまで影響するか**を、観測→差分→結論で整理できる

---

## 目的（この技術で到達する状態）
- "Secretsっぽい文字列"を見つけた段階で止まらず、**それが本当に秘密情報か／有効か／どこまで影響するか**を、観測→差分→結論で整理できる。
- 露出経路を「JS」「レスポンス」「ログ」「設定（クラウド/CI/CD）」に分解し、**再発防止に繋がる境界（どこで漏れたか）**を特定できる。
- 取り扱い（保存・共有・マスキング）を誤らず、ケースに **最小限の根拠**だけ残せる。

## 前提（対象・範囲・想定）
- 対象：APIキー、トークン、Cookie内トークン、接続文字列、秘密鍵、Webhook署名鍵、認証情報、内部URL、管理用IDなど。
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - CDN/WAF、SaaS連携、SPA+API、クラウド（AWS/Azure）前提
- できること/やらないこと（安全に検証する範囲）：
  - やる：観測→差分で確定する。推測を排し、Evidence（どこで何が露出したか）を保存し、結論（露出あり/なし/不明）を説明可能にする
  - やらないこと：値そのものはケースに残さず、**種類（例：外部APIキー相当）と露出場所**を記録する。Secretsは**取り扱い自体がリスク**。保存/共有は必ずマスクし、ケースは「場所・種類・根拠」中心にする
- 依存する前提知識（必要最小限）：
  - `01_topics/01_asm-osint/03_http_観測（ヘッダ・挙動）と意味.md`
  - `01_topics/01_asm-osint/04_js_フロント由来の攻撃面抽出.md`
  - `01_topics/01_asm-osint/05_cloud_露出面（CDN_WAF_Storage等）推定.md`
  - `01_topics/02_web/06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：
    - クライアント配布物（JS/ソースマップ/設定）：`app.js` / `config.js` に埋め込み、`*.map`（ソースマップ）に埋め込み、`window.__CONFIG__` のような初期設定JSONに埋め込み
    - HTTPレスポンス（ヘッダ/本文/エラー）：`Authorization` やカスタムヘッダの反射、デバッグレスポンスに設定値が載る、エラーに接続文字列・鍵の断片が含まれる
    - ログ（サーバログ/監査ログ/アプリログ）：リクエストヘッダ/ボディを丸ごとログ（トークンが記録）、例外ログに秘密値が混入
    - 設定・運用（クラウド/CI/CD/ストレージ公開）：公開バケット、公開コンテナ、設定ファイルの露出、CIログや成果物に秘密値が混入、メタデータ/管理APIの露出（設定ミス）
  - 扱わない（別ユニットへ接続）：
    - Secretsの詳細な管理方法（本プロジェクトは境界と成立根拠を優先）

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - クライアント配布物（JS/ソースマップ/設定）：どのURL（.js / .map / 設定JSON）に含まれるか
  - HTTPレスポンス（ヘッダ/本文/エラー）：どのエンドポイント/どの入力で含まれるか、どのヘッダ名に現れるか
  - ログ（サーバログ/監査ログ/アプリログ）：どのログ、どの設定、どの環境差分
  - 設定・運用（クラウド/CI/CD/ストレージ公開）：公開ストレージ/設定ファイルの到達性があるか
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：露出が「アプリ」ではなく「基盤設定」由来か
  - 信頼境界（外部連携・第三者・越境ポイント）：外部から到達可能な場所（JS/レスポンス/公開ストレージ等）で、秘密情報"相当"が観測できる
  - 権限境界（権限の切替/伝播/委任）：その値で「何ができるか」を先に整理（認証、署名、管理操作、外部API実行など）
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - "秘密"かどうかは、文字列ではなく「権限と用途」で決まる：見た目がそれっぽくても、公開してよい識別子は存在する（公開キー/クライアントID等）
  - 有効性（生きている/死んでいる）を推測で断言しない：無効化済でも、運用的には"過去に漏れた"事実が問題になる場合がある。"有効性不明"は unknown でよい（根拠が無いなら断言しない）
  - 露出経路の確定が最優先（再発防止に直結）：同じ秘密値でも、漏れた経路で対策が変わる（JS埋め込み、ログ混入、設定公開）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - 露出の有無と露出経路（JS/レスポンス/設定など）
  - 露出条件（未認証で見える、特定操作で出る 等）
  - 影響の方向（読み取り可能性、外部連携悪用可能性の"入口"）
- 何が"推定"できるか（推定の根拠/前提）：
  - 実際の権限範囲（何ができるか）の可能性（監査ログ/サービス側の権限情報が必要）
  - 値の有効性（失効済みか等）の可能性（運用情報が必要）
- 何は"言えない"か（不足情報・観測限界）：
  - 実際の権限範囲（何ができるか）の確定（監査ログ/サービス側の権限情報が必要）
  - 値の有効性（失効済みか等）の確定（運用情報が必要）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：yes（露出あり） → 外部から到達可能な場所（JS/レスポンス/公開ストレージ等）で、秘密情報"相当"が観測できる
  - パターンB：no（露出なし） → 想定経路を観測したが、秘密情報は確認できない（観測範囲を明記）
  - パターンC：unknown（不明） → 取得権限不足／ログ不足／条件再現不可／値の性質が判定できない。次に必要な観測点（どのログ、どの設定、どの環境差分）が定義されていること

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - クライアント配布物（JS/ソースマップ/設定）に埋め込まれたSecrets
  - HTTPレスポンス（ヘッダ/本文/エラー）に含まれるSecrets
  - ログ（サーバログ/監査ログ/アプリログ）に記録されたSecrets
  - 設定・運用（クラウド/CI/CD/ストレージ公開）で露出したSecrets
- 優先度の付け方（時間制約がある場合の順序）：
  1) 外部から到達可能な場所（JS/レスポンス/公開ストレージ等）で、秘密情報"相当"が観測できる → 最優先で重大
  2) ログ（サーバログ/監査ログ/アプリログ）に記録されたSecrets → "外部から見えない"前提でも、運用で漏えいし得る（内部流出・二次被害）
  3) 設定・運用（クラウド/CI/CD/ストレージ公開）で露出したSecrets → 露出が「アプリ」ではなく「基盤設定」由来か
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：JSにそれっぽい値がある → その値が参照される箇所（どのAPI呼び出しに使われるか）を観測し、用途を推定ではなく"利用箇所"で裏付ける
  - 攻め筋2：エラーに設定値が混ざる → 入力差分を最小にして再現性を確認し、エラー応答のどこに混入するかを確定する（同一条件で再現できないなら unknown）
  - 攻め筋3：公開ストレージ/設定公開が疑わしい → "到達性（公開）"を事実として確定し、公開範囲（一覧可/取得可）を yes/no/unknown で整理する
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - 露出が「アプリ」ではなく「基盤設定」由来か

## 次に試すこと（仮説A/Bの分岐と検証）
- 仮説A：JSにそれっぽい値がある
  - 成立条件：
    - クライアント配布物（JS/ソースマップ/設定）に埋め込まれたSecretsが観測される
  - 次の検証：
    - その値が参照される箇所（どのAPI呼び出しに使われるか）を観測し、用途を推定ではなく"利用箇所"で裏付ける
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 成功："何のための値か"をケースに根拠付きで残せる（推測を減らす）
    - 失敗：JSに秘密情報は含まれていない
- 仮説B：エラーに設定値が混ざる
  - 成立条件：
    - HTTPレスポンス（ヘッダ/本文/エラー）に含まれるSecretsが観測される
  - 次の検証：
    - 入力差分を最小にして再現性を確認し、エラー応答のどこに混入するかを確定する（同一条件で再現できないなら unknown）
  - 期待する観測：
    - 成功：混入が条件依存であることを説明できる（再現性が根拠）
    - 失敗：エラー応答に秘密情報は含まれていない
- 仮説C：公開ストレージ/設定公開が疑わしい
  - 成立条件：
    - 設定・運用（クラウド/CI/CD/ストレージ公開）で露出したSecretsが観測される
  - 次の検証：
    - "到達性（公開）"を事実として確定し、公開範囲（一覧可/取得可）を yes/no/unknown で整理する
  - 期待する観測：
    - 成功：アプリではなく基盤設定が境界であることを示せる
    - 失敗：公開ストレージ/設定公開は確認できない

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
    - `04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`
- 取得する証跡（目的ベースで最小限）：
  - 露出場所（URL/パス）、種類（外部APIキー相当、接続文字列相当 等）、露出条件（未認証で見える/特定操作後に見える 等）、証跡リンク（Proxyログ/HAR/スクショ/ログ位置）、結論（yes/no/unknown）
- 観測の取り方（どの視点で差分を見るか）：
  - 視点1：露出場所の確定
    - JS：どのURL（.js / .map / 設定JSON）に含まれるか
    - レスポンス：どのエンドポイント/どの入力で含まれるか
    - ヘッダ：どのヘッダ名に現れるか
    - 設定：公開ストレージ/設定ファイルの到達性があるか
  - 視点2：条件差分（最小）
    - 未認証 vs 認証済（同一エンドポイント）
    - 入力なし vs 特定入力（エラー誘発等は"最小"の差分で）
    - 入口違い（CDN経由/直アクセス等）※環境がある場合のみ
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/secrets_leakage 2>/dev/null
    cd ~/keda_evidence/secrets_leakage
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **最小限の差分セット** のみ（値そのものはケースに残さず、**種類（例：外部APIキー相当）と露出場所**を記録する）
      - Secretsは**取り扱い自体がリスク**。保存/共有は必ずマスクし、ケースは「場所・種類・根拠」中心にする
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host、User、Time、露出場所（URL/パス）、種類（外部APIキー相当、接続文字列相当 等）、露出条件、結論（yes/no/unknown）

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 目的：Secrets露出を「場所の確定」と「条件の差分」で固める（値そのものは扱わない）

# 1) 露出場所の確定
# - JS：どのURL（.js / .map / 設定JSON）に含まれるか
# - レスポンス：どのエンドポイント/どの入力で含まれるか
# - ヘッダ：どのヘッダ名に現れるか
# - 設定：公開ストレージ/設定ファイルの到達性があるか

# 2) 条件差分（最小）
# - 未認証 vs 認証済（同一エンドポイント）
# - 入力なし vs 特定入力（エラー誘発等は"最小"の差分で）
# - 入口違い（CDN経由/直アクセス等）※環境がある場合のみ

# 3) 記録（ケースに残す最小情報）
# - 露出場所（URL/パス）
# - 種類（外部APIキー相当、接続文字列相当 等）
# - 露出条件（未認証で見える/特定操作後に見える 等）
# - 証跡リンク（Proxyログ/HAR/スクショ/ログ位置）
# - 結論（yes/no/unknown）
~~~~

- この例で観測していること：
  - Secrets露出を「場所の確定」と「条件の差分」で固める（値そのものは扱わない）
- 出力のどこを見るか（注目点）：
  - 露出場所（URL/パス）、種類（外部APIキー相当、接続文字列相当 等）、露出条件、証跡リンク、結論（yes/no/unknown）
- この例が使えないケース（前提が崩れるケース）：
  - 値そのものはケースに残さず、**種類（例：外部APIキー相当）と露出場所**を記録する必要がある

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：V7（エラー処理・ログ）/ V8（データ保護）/ V6（暗号・鍵管理の前提）/ V1（アーキテクチャ）
  - 該当要件（可能ならID）：Secretsは"設定・運用境界"であり、実装不備だけでなく運用（配置/公開/記録）で漏れる
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：Secretsは"設定・運用境界"であり、実装不備だけでなく運用（配置/公開/記録）で漏れる。露出経路を「JS」「レスポンス」「ログ」「設定（クラウド/CI/CD）」に分解し、**再発防止に繋がる境界（どこで漏れたか）**を特定する必要がある。
    - 満たす：Secretsは"設定・運用境界"として適切に管理され、露出経路を「JS」「レスポンス」「ログ」「設定（クラウド/CI/CD）」に分解し、**再発防止に繋がる境界（どこで漏れたか）**を特定できる。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：設定レビュー・情報漏えい系の観点
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：設定レビュー・情報漏えい系の観点として、クライアント配布物（JS）/レスポンス/ログ/クラウド設定の漏えい経路を観測→差分で確定する。
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：脆弱性分析、侵害評価
  - 前後フェーズとの繋がり（1行）：推測を排し、Evidence（どこで何が露出したか）を保存し、結論（露出あり/なし/不明）を説明可能にする。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：Credential Access / Collection（例：Unsecured Credentials）
  - 攻撃者の目的（この技術が支える意図）：Secrets露出は後続の到達性・権限・横展開の意思決定を短絡させる。
  - 参照：https://attack.mitre.org/tactics/TA0006/（Credential Access）

## 参考（必要最小限）
- 親：`01_topics/02_web/06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- 関連（JS）：`01_topics/01_asm-osint/04_js_フロント由来の攻撃面抽出.md`
- 関連（クラウド露出）：`01_topics/01_asm-osint/05_cloud_露出面（CDN_WAF_Storage等）推定.md`
- 観測：`04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- 証跡：`04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`

## リポジトリ内リンク（最大3つまで）
- 関連 topics：`06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- 関連 topics：`01_topics/01_asm-osint/04_js_フロント由来の攻撃面抽出.md`
- 関連 labs：`04_labs/01_local/02_proxy_計測・改変ポイント設計.md`

---

## 深掘りリンク（最大8）
- `06_config_00_設定・運用境界（CORS ヘッダ Secrets）.md`
- `01_topics/01_asm-osint/03_http_観測（ヘッダ・挙動）と意味.md`
- `01_topics/01_asm-osint/04_js_フロント由来の攻撃面抽出.md`
- `01_topics/01_asm-osint/05_cloud_露出面（CDN_WAF_Storage等）推定.md`
- `04_labs/01_local/02_proxy_計測・改変ポイント設計.md`
- `04_labs/01_local/03_capture_証跡取得（pcap_harl_log）.md`
- `06_config_11_secrets_rotation_運用（回収_失効）.md`
- `02_playbooks/02_web_recon_入口→境界→検証方針.md`

---
