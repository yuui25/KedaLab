# 05_input_20_crlf_injection_01_response_splitting（header_body）
CRLF Injection（Response Splitting）：HTTPヘッダ境界（CRLF）を"境界入力"として扱わないと、レスポンスが分割され中継点を巻き込んで壊れる

---

## 目的（この技術で到達する状態）
- 「CRLFが入る/入らない」の話ではなく、**ヘッダ境界が割れる（Response Splitting）成立根拠** を観測で固める。
  1) どの入力がレスポンスヘッダに反映されるか（到達点）
  2) どの層（Origin/Reverse Proxy/CDN/Browser）がCRLFを境界として解釈するか
  3) "分割"の結果として何が起きるか（ヘッダ追加/ステータス/ボディ混線/キャッシュ格納）
  4) 影響半径（自分だけ/共有キャッシュ/別ユーザ）を境界で説明できる
  5) 修正要求を「入力検証」「生成API統一」「中継点設定」「監視」に落とせる

## 前提（対象・範囲・想定）
- 対象：許可された範囲のWebアプリ/環境のみ。
- 想定する環境（例：クラウド/オンプレ、CDN/WAF有無、SSO/MFA有無）：
  - 多段（CDN→Proxy→Origin）が一般的。
- できること/やらないこと（安全に検証する範囲）：
  - やらないこと：検証は **安全設計（影響半径最小化）** と **観測重視** で行う。レスポンス分割は第三者影響（キャッシュ/共有プロキシ）を含み得るため、多段（CDN→Proxy→Origin）のどこで成立するかを切り分けて所見化する。
- 依存する前提知識（必要最小限）：
  - `01_topics/02_web/05_input_17_email_header_injection（SMTP境界）.md`
- 扱う範囲（本ファイルの守備範囲）
  - 扱う：
    - Response Splitting（header/body境界）としてのCRLF注入
    - 反映ポイント（Location、Set-Cookie、Content-Disposition、カスタムヘッダ、ログ相関ヘッダ等）
    - 分割が成立する条件（層・パーサ・正規化）
    - 観測の取り方（証拠の積み上げ）
  - 扱わない（別ユニットへ接続）：
    - Cache Poisoning（配布範囲やキーの詳細） → `05_input_19_cache_poisoning_0x_*.md`
    - Request Smuggling（front/back解釈差の詳細） → `05_input_18_http_request_smuggling_0x_*.md`
    - XSSとしての最終到達（格納/反射/DOM） → `05_input_06_xss_0x_*.md`
    - Open Redirectの入口整理 → `05_input_10_open_redirect（遷移先信頼境界）.md`

## 観測ポイント（何を見ているか：プロトコル/データ/境界）
- 観測対象（プロトコル/データ構造/やり取りの単位）：
  - どの入力がレスポンスヘッダに反映されるか（到達点）
  - どの層（Origin/Reverse Proxy/CDN/Browser）がCRLFを境界として解釈するか
  - "分割"の結果として何が起きるか（ヘッダ追加/ステータス/ボディ混線/キャッシュ格納）
- 境界の観点：
  - 資産境界（管理主体・委託先・対象範囲の線引き）：どの層（Origin/Reverse Proxy/CDN/Browser）がCRLFを境界として解釈するか
  - 信頼境界（外部連携・第三者・越境ポイント）：レスポンス分割は第三者影響（キャッシュ/共有プロキシ）を含み得る
  - 権限境界（権限の切替/伝播/委任）：影響半径（自分だけ/共有キャッシュ/別ユーザ）
- 重要なフィールド/差分/状態（「ここが変わると意味が変わる」点）：
  - レスポンスの形状（ステータスコード、ヘッダが増える/減る/順序が崩れる/同名が複数になる、Content-Length / Transfer-Encoding / Connection など"境界系ヘッダ"が不自然になっていないか）
  - 中継点の関与シグナル（キャッシュ関与（Age等）や経路情報（Via等）が見える範囲で増減するか）

## 結果の意味（その出力が示す状態：何が言える/言えない）
- 何が"確定"できるか：
  - どの入力がレスポンスヘッダに反映されるか（到達点）
  - どの層（Origin/Reverse Proxy/CDN/Browser）がCRLFを境界として解釈するか
- 何が"推定"できるか（推定の根拠/前提）：
  - "分割"の結果として何が起きるか（ヘッダ追加/ステータス/ボディ混線/キャッシュ格納）
  - 影響半径（自分だけ/共有キャッシュ/別ユーザ）を境界で説明できる
- 何は"言えない"か（不足情報・観測限界）：
  - すべての層での完全な断定（観測範囲に依存）
  - すべての入力面を網羅した断定（観測範囲に依存）
- よくある状態パターン（正常/異常/境界がズレている等）：
  - パターンA：アプリ層で拒否されている（成立しない） → 入力はヘッダ反映点に到達していない、またはフレームワークが制御文字を拒否/正規化している
  - パターンB：ヘッダ形状が変わった（成立兆候） → 境界が割れる可能性がある
  - パターンC：H2/H1境界が疑わしい場合 → 変換境界での正規化不一致が主因の可能性

## 攻撃者視点での利用（意思決定：優先度・攻め筋・次の仮説）
- この状態が示す"狙い目"：
  - Location（リダイレクト）：リダイレクト先をユーザ入力で決める設計は多い（ログイン後遷移、return_to等）
  - Set-Cookie / Cookie属性：セッション境界に直結（Secure/HttpOnly/SameSite/Domain/Path）
  - Content-Disposition（ダウンロード名）：filename等にユーザ入力が混ざる設計がある
  - 反射されやすいカスタムヘッダ：X-Request-Id、X-Trace、X-User 等の"デバッグ系"
- 優先度の付け方（時間制約がある場合の順序）：
  1) ヘッダ改ざん（境界ヘッダの上書き） → Cache-Control 等が変わる → キャッシュ格納条件が変化し得る（Cache Poisoningへ接続）
  2) レスポンス分割→後続混線 → "別レスポンス"が混入する形になれば、共有プロキシ/キャッシュ経由で第三者影響が発生し得る
  3) 誤誘導・誤配布（実害として強い） → LocationやHTMLの参照先が変わる → ユーザが"正規の流れ"から外れる
- 代表的な攻め筋（この観測から自然に繋がるもの）：
  - 攻め筋1：Origin（アプリ/サーバ）がヘッダ生成時点で拒否しない → レスポンスヘッダが意図せず増減/分断している（"境界が割れた結果"が残る）
  - 攻め筋2：Originは拒否するが、中継点で再解釈/再構築される → Proxyがエラー/リダイレクト/変換を生成し、その生成元に未検証入力が混ざる
- 「見える/見えない」による戦略変更（例：CDN配下、SSO前提、外部委託先など）：
  - HTTP/2/HTTP/1変換境界で不一致が起きる → H2はヘッダが"行"ではなくフィールドとして扱われるが、H1へ落とす段で正規化が起きる

## 次に試すこと（仮説A/Bの分岐と検証）
- 仮説A：アプリ層で拒否されている（成立しない）場合
  - 次の検証：
    - "同じ入力が別のヘッダ反映点に行く"経路を探す（ファイル名、return_to、デバッグヘッダ等）
    - エラー経路（400/500/リダイレクト）で同入力が反映されないか観測（中継点生成を疑う）
  - 期待する観測（成功/失敗時に何が見えるか）：
    - 入力はヘッダ反映点に到達していない、またはフレームワークが制御文字を拒否/正規化している
- 仮説B：ヘッダ形状が変わった（成立兆候）場合
  - 次の検証：
    - どの層で変わったかを切り分け（Origin直/エッジ経由で差を見る）
    - キャッシュ関与（ヒット/ミス、TTL）を確認し、第三者影響の可能性があるなら検証を止めて範囲/合意を取る
    - "影響の型"を確定（ヘッダ追加止まりか、分割・混線の兆候があるか）
  - 期待する観測：
    - 境界が割れる可能性があることが示される
- 仮説C：H2/H1境界が疑わしい場合
  - 次の検証：
    - `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md` と接続し、同一経路での解釈差を"観測"中心で詰める
  - 期待する観測：
    - 変換境界での正規化不一致が主因の可能性が示される

## 手を動かす検証（Labs連動：観測点を明確に）
- 検証環境（関連する `04_labs/`）
  - 参照ファイル：
    - `04_labs/02_web/05_input/20_crlf_injection_01_response_splitting_header_body/`（追加候補）
- 取得する証跡（目的ベースで最小限）：
  - レスポンスの形状（ステータスコード、ヘッダが増える/減る/順序が崩れる/同名が複数になる）、中継点の関与シグナル、相関ログ（Origin：受信した入力、レスポンス生成時の例外/拒否ログ、Proxy/CDN：正規化/拒否ログ、生成レスポンス（エラー/リダイレクト）ログ）
- 観測の取り方（どの視点で差分を見るか）：
  - メモに必ず残す項目：入力項目、ヘッダ反映点、層（Origin/Reverse Proxy/CDN/Browser）、分割の結果、影響半径
- 実施方法（最高に具体的）：観測の準備と相関キー
  - 証跡ディレクトリ（必須）
    ~~~~
    mkdir -p ~/keda_evidence/crlf_injection_response_splitting 2>/dev/null
    cd ~/keda_evidence/crlf_injection_response_splitting
    ~~~~
  - 検証の前提を固定（スコープ事故を防ぐ）
    - 必須で決める（レポート先頭に書く）
      - 対象は **許可されたスコープ** のみ
      - 観測は **安全設計（影響半径最小化）** と **観測重視** で行う
      - レスポンス分割は第三者影響（キャッシュ/共有プロキシ）を含み得るため、多段（CDN→Proxy→Origin）のどこで成立するかを切り分けて所見化する
  - 相関キー（最低限）を作る（後で必ず効く）
    - Host、User、Time、入力項目、ヘッダ反映点、層、分割の結果、影響半径

## コマンド/リクエスト例（例示は最小限・意味の説明が主）
> 例示は"手段"であり"結論"ではない。必ず「何を観測している例か」を添える。

~~~~
# 目的は「境界が割れた結果」を観測で確定すること。
# - 同一入力を (1) Origin直、(2) Edge/CDN経由 で比較して層差を取る
# - レスポンスヘッダの形状（ヘッダ増減、重複、空行、CL/TEなど境界ヘッダ）を記録する
# - 第三者影響が疑われる（共有キャッシュ）場合は、検証を増やさずに証跡と範囲確認へ切り替える
~~~~

- この例で観測していること：
  - どの入力がレスポンスヘッダに反映されるか（到達点）、どの層（Origin/Reverse Proxy/CDN/Browser）がCRLFを境界として解釈するか
- 出力のどこを見るか（注目点）：
  - レスポンスの形状（ステータスコード、ヘッダが増える/減る/順序が崩れる/同名が複数になる）、中継点の関与シグナル、相関ログ
- この例が使えないケース（前提が崩れるケース）：
  - ヘッダ反映機能がない場合、観測できない

## ガイドライン対応（ASVS / WSTG / PTES / MITRE ATT&CK：毎回記載）
- ASVS：
  - 該当領域/章：入出力検証、HTTP処理
  - 該当要件（可能ならID）：レスポンスヘッダへ反映する値は **CR/LF禁止**（正規化/拒否）を基本とし、フレームワーク/サーバ設定で二重化する。リダイレクト先やファイル名等は allowlist/エンコードで固定し、ヘッダ生成APIを統一して"自作連結"を禁止する。
  - このファイルの内容が「満たす/破れる」ポイント：
    - 破れる：アプリがレスポンスヘッダ（例：Location / Set-Cookie / Content-Disposition / 任意カスタムヘッダ）へ未検証入力を反映し、かつ中継点/クライアントがCRLFを"ヘッダ境界"として解釈すると、ヘッダ改ざん・レスポンス分割・キャッシュ汚染・誤誘導が起きる。実装が安全でも、中継点（CDN/Proxy/WAF）との解釈差で成立する。
    - 満たす：レスポンスヘッダへ反映する値は **CR/LF禁止**（正規化/拒否）を基本とし、フレームワーク/サーバ設定で二重化する。リダイレクト先やファイル名等は allowlist/エンコードで固定し、ヘッダ生成APIを統一して"自作連結"を禁止する。中継点も含めて、ヘッダの不正文字を拒否する一貫設定と監視（ログ/アラート）を持つ。
  - 参照：https://github.com/OWASP/ASVS
- WSTG：
  - 該当カテゴリ/テスト観点：入力が「レスポンスヘッダ構築」に到達するか、到達した際に **(1) アプリ層で拒否されるか**、**(2) 中継点が正規化/拒否するか**、**(3) キャッシュ/ブラウザへどう到達するか** を観測で確定する。単に "%0d%0a が入る" で止めず、「境界が本当に割れるか」を証拠化する。
  - 該当が薄い場合：この技術が支える前提（情報収集/境界特定/到達性推定 等）：CRLF Injection（Response Splitting）の特定と成立条件の詰め方
  - 参照：https://owasp.org/www-project-web-security-testing-guide/
- PTES：
  - 該当フェーズ：脆弱性分析〜侵害評価
  - 前後フェーズとの繋がり（1行）：脆弱性分析〜侵害評価。レスポンス分割は第三者影響（キャッシュ/共有プロキシ）を含み得るため、検証は **安全設計（影響半径最小化）** と **観測重視** で行う。多段（CDN→Proxy→Origin）のどこで成立するかを切り分けて所見化する。
  - 参照：https://pentest-standard.readthedocs.io/
- MITRE ATT&CK：
  - 該当戦術（必要なら技術）：T1190（公開アプリの脆弱性悪用）に接続し得る。Impact（誤配布/誤誘導/可用性劣化）や Collection（混線による情報露出）に接続し得るが、断定は「分割の成立」と「配布範囲」の証跡が揃ってから行う。
  - 攻撃者の目的（この技術が支える意図）：CRLF Injection（Response Splitting）の特定と成立条件の詰め方
  - 参照：https://attack.mitre.org/tactics/TA0001/（Initial Access）

## 参考（必要最小限）
- CRLF Injection（Response Splitting）の定義と解説
- HTTPヘッダ境界（CRLF）の説明
- 多段（CDN→Proxy→Origin）での成立条件

## リポジトリ内リンク（最大3つまで）
- 関連 topics：`05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- 関連 topics：`05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- 関連 labs：`04_labs/02_web/05_input/20_crlf_injection_01_response_splitting_header_body/`（追加候補）

---

## 深掘りリンク（最大8）
- `05_input_20_crlf_injection_02_downstream（proxy_log_cache）.md`
- `05_input_19_cache_poisoning_02_unkeyed（headers_params）.md`
- `05_input_19_cache_poisoning_03_poisoned_object（stored_response）.md`
- `05_input_18_http_request_smuggling_01_te_cl（proxy_desync）.md`
- `05_input_18_http_request_smuggling_03_http2_frontend（h2_to_h1）.md`
- `05_input_10_open_redirect（遷移先信頼境界）.md`
- `05_input_06_xss_01_反射_境界モデル.md`
- `06_config_03_セキュリティヘッダ（CSP_HSTS_Frame_Referrer）.md`

---
